---
title: "SSF simulation all birds"
author: "Luis Antonio Arias Medellin"
date: "August 13, 2019"
output: html_document
---

#MULTIPLE BIRDS

## FORMAT DATA BASE FOR ANALYSIS

http://tlocoh.r-forge.r-project.org/tips/isopleth_overlap_auto.html

## Load required packages

```{r, include=FALSE}
#Load libraries
library("openxlsx")
library("NISTunits")
library("rgdal")
#library("ggmap")
library("SDMTools")
library("raster")
#library("MetaLandSim") # need to run code source("https://bioconductor.org/biocLite.R") biocLite("Biobase")
#library("rgeos")
library("maps")
#library("maptools")
#library("geosphere")
library("amt")
library("tidyr")
#library("cowplot")
#library("reshape2")
library("dplyr")
library("ggplot2")
#library("ggrepel")
library("GGally")
library("parallel")
library("doParallel")
library("foreach")
library("sp")
library("stats")
#library("knitr")
library("ggpubr")
```

```{r}
#Convert the Rmd file to R file so that it can be read on the super computer
#purl("SSF_simulation_all_birds.Rmd",output="SSF simulation all birds R file.R")

```


#Prepare GPS data

```{r, include=FALSE}
#Remove anything on workspace
rm(list=ls(all=TRUE))

#Source functions
source("Clean SSF data base.R") #I just dpulicated the code I used for cleaning the tleemtry data just in case I modified the latter, so to avoid that the changes affect the present code 

#Fuction for cleaning telemetry data base
clean.tel.data()

#Copy data base
original.database<-prueba

#Select only columns of interest
original.database<-original.database[,c("LOCATION.X","LOCATION.Y","TIME","FREQ")]

#Rename columns
colnames(original.database)<-c("x","y","t","id")

#Number of GPS points per individual
original.database %>%
  group_by(id) %>% 
  summarise(num.obs=n()) %>% 
  ungroup() %>% 
  arrange(desc(num.obs))

#Remove elements that I will not use
rm(clean.freq,clean.tel.data,prueba,m)
```

#Prepare map

```{r}
#Load raster
land_use_raster<-raster("Map layers/Aug27_15rasters/forest27")

#Make a matrix to reclsify values from 1 to 1 and the new value is 0
m<-matrix(c(0,1,0,
            1,2,1),ncol=3,byrow=T) 

#Reclassify values
land_use_raster<-reclassify(land_use_raster,m)
names(land_use_raster) <- "forest27"

rm(m)
```

#Prepare information that will have the frequency of each individual, the patch were it was captured and the information of each patch where the individual was captured

```{r}
#Read excel data base of patch id, patch size and % forest
patches.info<-read.xlsx("Data bases/Information patches Costa Rica.xlsx",sheet=1)
freq.patches<-read.xlsx("Data bases/Frequencies patches.xlsx",sheet=1)

#Keep columns of interest
patches.info<-patches.info[,c("PATCH_ID","PERCENT_FOREST","ELEVATION","Psize")]

#Rename columns
colnames(patches.info)<-c("Patch","percent_forest","elevation","patch_size") #****There is no information on patch 15, 27, 28, 35, 62, 63. Patches 12 and 39 are on the database but there is no information since they have NA

```


```{r}
#Create a data frame with id as the first column and the second column has a data frame inside it with the x,y and time (t)
condensed.dataframe <- original.database %>% nest(-id)

#Show the frequency of the birds I followed
unique(condensed.dataframe$id)

#Subset certain individuals since I cannot run the code with certain frequencies. ****CHECK LATER HOW TO RUN THE CODE WITH ALL FREQUENCIES
condensed.dataframe.subset<-subset(condensed.dataframe,condensed.dataframe$id==232 |
                  condensed.dataframe$id==881 |
                  condensed.dataframe$id==942 |
                  condensed.dataframe$id==312 |
                  condensed.dataframe$id==171 |
                  condensed.dataframe$id==352 |
                  condensed.dataframe$id==511 |
                  condensed.dataframe$id==551 |
                  condensed.dataframe$id==731 |
                  condensed.dataframe$id==760 |
                  condensed.dataframe$id==851 |
                  condensed.dataframe$id==881 |
                  condensed.dataframe$id==973 |
                  condensed.dataframe$id==392 |
                  condensed.dataframe$id==202)
                    


#432 only moved in forested area, so the interaction terms of step length and habitat selection between habitats is not working since there are no steps in the matrix
#273 has only 4 movments in the forest, so the interaction is not working
#591 only moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there are no steps in the FOREST
#631 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 1 step in the FOREST
#672 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#702 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#791 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#821 MOSTLY moved in forest area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the matrix
#910 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#472 is giving me a very unsual value of the parameter and I do not know why
condensed.dataframe.subset.remaining<-subset(condensed.dataframe,condensed.dataframe$id==472 |
                    condensed.dataframe$id==910 |
                    condensed.dataframe$id==821 |
                    condensed.dataframe$id==791 |
                    condensed.dataframe$id==702 |
                    condensed.dataframe$id==672 |
                    condensed.dataframe$id==631 |
                    condensed.dataframe$id==591 |
                    condensed.dataframe$id==273 |
                    condensed.dataframe$id==432 ) 


#273, 352,511 472, 591, 672, 702, 791, 821, 973, 202 cannot fit model
#312, 171,731, 760, 392, 631, 851 give NA or INF values on estimate or confidence intervals
```

```{r}
#Make a track for each individual
condensed.dataframe.subset <- condensed.dataframe.subset %>%
mutate(trk = lapply(data, function(d) {
mk_track(d, x, y, t )
}))

condensed.dataframe.subset.remaining <- condensed.dataframe.subset.remaining %>%
mutate(trk = lapply(data, function(d) {
mk_track(d, x, y, t )
}))

#Make a track for each individual but including all samped birds. I am doing this so that I can have statistics of step length, habitat selection and turning angle of all birds and not only a subset of them
condensed.dataframe <- condensed.dataframe %>%
mutate(trk = lapply(data, function(d) {
mk_track(d, x, y, t )
}))
```

```{r}
#Summarize sampling rate of all individuals
condensed.dataframe.subset %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
select(id, sr) %>% unnest

condensed.dataframe.subset.remaining %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
select(id, sr) %>% unnest
```

#Make tracks
```{r}


condensed.dataframe.subset <- condensed.dataframe.subset %>% mutate(ssf = lapply(trk, function(x) {
x %>% 
    track_resample(rate = minutes(5), tolerance = minutes(2)) %>% #A track will be considered if the two consecutive GPS points are separated by 5 minutes +- 2 minutes of tolerance
    filter_min_n_burst(min_n = 3) %>% #Keep only tracks that have three consecutive locations, which is the minimum requeried for doing the analysis
    steps_by_burst() %>% #Converts the points to tracks
    random_steps() %>% #Makes 9 random steps
    extract_covariates(land_use_raster, where = "both") %>% #Extracts covariates of vegetation on initial and ending location. In "amt tutorial.pdf" it explains the following: covariate values at the start and the end of a step can also be included in the model as interaction with each other, to test hypotheses of the type: Are animals more likely to stay in a given habitat, if they are already in the habitat?
    mutate(forest27_start = factor(forest27_start, levels = c(0, 1), labels = c("matrix", "forest"))) %>% #factor (forest27_start you have to check the name of the column of the data base that is generated one step before (in this case is forest27_start). Just run the 2 precedent pipe lines and a tibble with the names of the column will appeaar)
    mutate(forest27_end = factor(forest27_end, levels = c(0, 1), labels = c("matrix", "forest"))) %>% 
    mutate(log_sl_ = log(sl_)) #Obtain logarithm of step lenght
}))



condensed.dataframe.subset.remaining <- condensed.dataframe.subset.remaining %>% mutate(ssf = lapply(trk, function(x) {
x %>% 
    track_resample(rate = minutes(5), tolerance = minutes(2)) %>% #A track will be considered if the two consecutive GPS points are separated by 5 minutes +- 2 minutes of tolerance
    filter_min_n_burst(min_n = 3) %>% #Keep only tracks that have three consecutive locations, which is the minimum requeried for doing the analysis
    steps_by_burst() %>% #Converts the points to tracks
    random_steps() %>% #Makes 9 random steps
    extract_covariates(land_use_raster, where = "both") %>% #Extracts covariates of vegetation on initial and ending location. In "amt tutorial.pdf" it explains the following: covariate values at the start and the end of a step can also be included in the model as interaction with each other, to test hypotheses of the type: Are animals more likely to stay in a given habitat, if they are already in the habitat?
    mutate(forest27_start = factor(forest27_start, levels = c(0, 1), labels = c("matrix", "forest"))) %>% #factor (forest27_start you have to check the name of the column of the data base that is generated one step before (in this case is forest27_start). Just run the 2 precedent pipe lines and a tibble with the names of the column will appeaar)
    mutate(forest27_end = factor(forest27_end, levels = c(0, 1), labels = c("matrix", "forest"))) %>% 
    mutate(log_sl_ = log(sl_)) #Obtain logarithm of step lenght
}))


#Doing the sam process for the data base with all individuals
condensed.dataframe <- condensed.dataframe %>% mutate(ssf = lapply(trk, function(x) {
x %>% 
    track_resample(rate = minutes(5), tolerance = minutes(2)) %>% #A track will be considered if the two consecutive GPS points are separated by 5 minutes +- 2 minutes of tolerance
    filter_min_n_burst(min_n = 3) %>% #Keep only tracks that have three consecutive locations, which is the minimum requeried for doing the analysis
    steps_by_burst() %>% #Converts the points to tracks
    random_steps() %>% #Makes 9 random steps
    extract_covariates(land_use_raster, where = "both") %>% #Extracts covariates of vegetation on initial and ending location. In "amt tutorial.pdf" it explains the following: covariate values at the start and the end of a step can also be included in the model as interaction with each other, to test hypotheses of the type: Are animals more likely to stay in a given habitat, if they are already in the habitat?
    mutate(forest27_start = factor(forest27_start, levels = c(0, 1), labels = c("matrix", "forest"))) %>% #factor (forest27_start you have to check the name of the column of the data base that is generated one step before (in this case is forest27_start). Just run the 2 precedent pipe lines and a tibble with the names of the column will appeaar)
    mutate(forest27_end = factor(forest27_end, levels = c(0, 1), labels = c("matrix", "forest"))) %>% 
    mutate(log_sl_ = log(sl_)) #Obtain logarithm of step lenght
}))

```

#Plot habitat selection by bird (includes all birds)
```{r,purl=FALSE}
#Obtain the information from the condensed data frame
tracking.database.unlisted<- condensed.dataframe %>% 
  select(id, ssf) %>% 
  unnest %>%
  select(id,case_,step_id_,sl_,ta_,forest27_start,forest27_end,log_sl_) %>% 
  filter(case_==TRUE) %>% 
  ungroup()

counts<-table(tracking.database.unlisted$forest27_end,tracking.database.unlisted$id)
par(mar=c(5,5,2,9),xpd=T)
barplot(counts,xlab="Bird id",ylab="Proportion of GPS points per habitat",col=c("grey50","grey"),las=2)

legend("topright",legend=c("Non-forested area","Forested area"),fill=c("grey","grey50"),bty="n")

counts<-data.frame(prop.table(t(counts),margin=1))

counts<-cbind(counts[1:(nrow(counts)/2),c("Var1","Freq")],counts[((nrow(counts)/2)+1):nrow(counts),"Freq"]) 
colnames(counts)<-c("freq","matrix","forest")
counts<-counts[order(-counts$matrix),]
counts.matrix<-t(data.matrix(counts[,c("matrix","forest")]))
colnames(counts.matrix)<-counts[,1]

#jpeg("Graphs/forest end by id frequency.jpg",quality=100,width=1000,height=700)
##**FOR THE FORESTED AREA, A LOT OF FREQUENCIES DO NOT HAVE OBSERVATION. IN ADDITION, THE PROPORTION OF 
par(mar=c(5,5,2,9),xpd=T)
barplot(counts.matrix,xlab="Bird id",ylab="Proportion of GPS points per habitat",col=c("grey","grey50"),las=2)

legend(x=17,y=0.8,legend=c("Non-forested area","Forested area"),fill=c("grey","grey50"),bty="n")

#Summary of proporiton of points in matrix
counts %>% 
  filter(matrix<1 & matrix>0) %>% 
  summary()

#Boxplot of proporiton of points in matrix
counts %>% 
  filter(matrix<1 & matrix>0) %>% 
  ggplot(aes(y=matrix)) +
  geom_boxplot()

#dev.off()
```


```{r,purl=FALSE}
#Step length statistics
#Step length by bird
tracking.database.unlisted %>% 
  mutate(id=as.factor(id)) %>% 
  ggplot(aes(x=id,y=log_sl_)) +
  geom_boxplot() +
  xlab("Bird id") +
  ylab("Log step length")
#ggsave("Graphs/Step length by bird.jpg")

#Satistics of step lenght
summary(tracking.database.unlisted$sl_)
table(round(tracking.database.unlisted$sl_))
tapply(tracking.database.unlisted$sl_,tracking.database.unlisted$forest27_start,summary)

###Density plot of log step length per vegetal cover
tracking.database.unlisted %>% 
  ggplot(aes(x=log_sl_)) + 
  geom_histogram(aes(y=..density..),colour="black", fill="white") +
  geom_density(alpha=.2, fill="#FF6666") +
  facet_wrap(~forest27_start)

tracking.database.unlisted %>% 
  mutate(breaks=cut(.$sl_,c(0,1,10,30,50,100,max(.$sl)))) %>% 
  group_by(breaks) %>% 
  summarise(proportion=n()/nrow(tracking.database.unlisted)) %>% 
  ungroup()


##Proportion of steps by step lenght in matrix
matrix<-tracking.database.unlisted %>% 
  filter(forest27_start=="matrix") %>% 
  mutate(breaks=cut(.$sl_,c(0,1,10,30,50,100,max(.$sl)))) %>% 
  group_by(breaks) %>% 
  summarise(proportion=n()) %>% 
  ungroup() %>%
  mutate(proportion=proportion/tracking.database.unlisted %>% filter(forest27_start=="matrix") %>% nrow()) %>% 
  ggplot(aes(x=breaks,y=proportion)) +
  geom_col() +
  xlab("Step length (m)") +
  ylab("Proportion") +
  ggtitle("Matrix")



##Proportion of steps by step lenght in forest
forest<-tracking.database.unlisted %>% 
  filter(forest27_start=="forest") %>% 
  mutate(breaks=cut(.$sl_,c(0,1,10,30,50,100,max(.$sl)))) %>% 
  group_by(breaks) %>% 
  summarise(proportion=n()) %>% 
  ungroup() %>%
  mutate(proportion=proportion/tracking.database.unlisted %>% filter(forest27_start=="forest") %>% nrow()) %>% 
  ggplot(aes(x=breaks,y=proportion)) +
  geom_col() +
  xlab("Step length (m)") +
  ylab("Proportion") +
  ggtitle("Forest")

#Combine graphs
ggarrange(matrix,forest,ncol = 2, nrow = 1)

#Boxplot of log step length by vegetation cover
tracking.database.unlisted %>% 
  ggplot(aes(x=forest27_start,y=log_sl_)) +
  geom_boxplot() +
  xlab("Vegetal cover") +
  ylab("Log step length")
ggsave("Graphs/Step length by vegetal cover.jpg")


#Wilcoxon test for differences in step length by vegetal cover
wilcox.test(tracking.database.unlisted %>% select(forest27_start,sl_) %>% filter(forest27_start=="matrix") %>% select(sl_) %>% .$sl_,tracking.database.unlisted %>% select(forest27_start,sl_) %>% filter(forest27_start=="forest") %>% select(sl_) %>% .$sl_)

rm(counts,counts.matrix,matrix,forest)


```


```{r,purl=FALSE}
#Turning angle by bird
tracking.database.unlisted %>% 
  mutate(id=as.factor(id)) %>% 
  ggplot(aes(x=id,y=ta_)) +
  geom_boxplot() +
  xlab("Bird id") +
  ylab("Turning angle") +
  geom_hline(yintercept=c(-180,180),linetype="dashed")
#ggsave("Graphs/Turning angle by bird.jpg")

#Histogram of turning angle of all birds
tracking.database.unlisted %>% 
  ggplot(aes(x=ta_)) +
  geom_histogram() +
  xlab("Bird id") +
  ylab("Turning angle")

#Histogram of turning angle of all birds but without a 0 angle
tracking.database.unlisted %>% 
  filter(ta_!=0) %>% 
  ggplot(aes(x=ta_)) +
  geom_histogram() +
  xlab("Bird id") +
  ylab("Turning angle")
 
#Histogram of turning angle of all birds by vegetal cover
tracking.database.unlisted %>% 
  ggplot(aes(x=ta_)) +
  geom_histogram() +
  xlab("Bird id") +
  ylab("Turning angle") +
  facet_wrap(~forest27_start,scales="free")

#Histogram of turning angle of all birds by vegetal cover but without 0 turning angle
tracking.database.unlisted %>% 
  filter(ta_!=0) %>% 
  ggplot(aes(x=ta_)) +
  geom_histogram() +
  xlab("Bird id") +
  ylab("Turning angle") +
  facet_wrap(~forest27_start,scales="free")

borrar <- tracking.database.unlisted %>% 
  mutate(ta_=if_else(ta_<0,ta_+360,ta_)) %>% 
  #mutate(breaks=cut(.$ta_,seq(from=-180,to=180,by=10))) %>%
  mutate(breaks=as.character(cut(.$ta_,seq(from=0,to=360,by=10))))

borrar$breaks <- ifelse(is.na(borrar$breaks)==TRUE,0,borrar$breaks)


#Graph with 0 angle included
borrar %>%
  ggplot(aes(x=breaks)) +
  geom_histogram(stat="count")+
  coord_polar()

#Graph with 0 angle included by vegetal cover
borrar %>%
  ggplot(aes(x=breaks)) +
  geom_histogram(stat="count")+
  coord_polar() +
  facet_wrap(~forest27_start)

#Graph without 0 angle 
borrar %>% 
  filter(breaks!="0")%>%
  ggplot(aes(x=breaks)) +
  geom_histogram(stat="count")+
  coord_polar() +
  facet_wrap(~forest27_start)


#Statistics for tunring angle
summary(borrar$ta_)
tapply(borrar$ta_,borrar$forest27_start,summary)
tapply(borrar %>% filter(ta_>0) %>% .$ta_, borrar %>% filter(ta_>0) %>% .$forest27_start,summary)

#Wilcoxon test for differences in turning angle by vegetal cover
wilcox.test(tracking.database.unlisted %>% select(forest27_start,ta_) %>% filter(forest27_start=="matrix") %>% select(ta_) %>% .$ta_,tracking.database.unlisted %>% select(forest27_start,ta_) %>% filter(forest27_start=="forest") %>% select(ta_) %>% .$ta_)

#Boxplot of turning angles without 0
tracking.database.unlisted %>% 
  filter(ta_!=0) %>% 
  ggplot(aes(x=forest27_start,y=ta_)) +
  geom_boxplot()

#T. test for differences in turning angle by vegetal cover without step length > 1
t.test(tracking.database.unlisted %>% filter(sl_>1) %>%  select(forest27_start,ta_) %>% filter(forest27_start=="matrix") %>% select(ta_) %>% .$ta_,tracking.database.unlisted %>% filter(sl_>1) %>% select(forest27_start,ta_) %>% filter(forest27_start=="forest") %>% select(ta_) %>% .$ta_)


library("circular")
library("REdaS")
library("rotations")
#Obtain the von mises mean and kappa concentration parameter fo the truning angle by bird
von.mises.parameters <- tracking.database.unlisted %>% 
  mutate(ta_=deg2rad(ta_)) %>% 
  group_by(id) %>% 
  summarise(mu=as.numeric(mle.vonmises(ta_)$mu),
            kappa=mle.vonmises(ta_)$kappa) %>% 
  ungroup()

#Obtain the von mises mean and kappa concentration parameter fo the truning angle by bird and vegetation cover
von.mises.parameters.by.vegetation <- tracking.database.unlisted %>% 
  mutate(ta_=deg2rad(ta_)) %>% 
  group_by(id,forest27_start) %>% 
  summarise(mu=as.numeric(mle.vonmises(ta_)$mu),
            kappa=mle.vonmises(ta_)$kappa) %>% 
  ungroup()

#Boxplot of von mises mean  parameter fo the truning angle by vegetation cover
von.mises.parameters.by.vegetation %>% 
  ggplot(aes(x=forest27_start,y=mu)) +
  geom_boxplot() +
  xlab("Vegetation cover") +
  ylab("Mean")

#I will do a test to see if the mean of the von mises distribution varies between vegetal cover but I need a wide format data base
von.mises.parameters.by.vegetation.spread <- von.mises.parameters.by.vegetation %>% 
  select(-kappa) %>% 
  spread(forest27_start,mu)

#Parametric and non-parametric test
t.test(von.mises.parameters.by.vegetation.spread$matrix,von.mises.parameters.by.vegetation.spread$forest)
wilcox.test(von.mises.parameters.by.vegetation.spread$matrix,von.mises.parameters.by.vegetation.spread$fores)

#Summary of mean of von mises distribution by vegetal cover
tapply(von.mises.parameters.by.vegetation$mu,von.mises.parameters.by.vegetation$forest27_start,summary)




#Boxplot of von mises kappa  parameter fo the truning angle by vegetation cover
von.mises.parameters.by.vegetation %>%
  filter(kappa<30) %>% 
  ggplot(aes(x=forest27_start,y=kappa)) +
  geom_boxplot() +
  xlab("Vegetation cover") +
  ylab("Kappa concentration parameter")


#I will do a test to see if the kappa concentration parameter of the von mises distribution varies between vegetal cover but I need a wide format data base
von.mises.parameters.by.vegetation.spread <- von.mises.parameters.by.vegetation %>% 
  select(-mu) %>% 
  filter((kappa==Inf)==FALSE) %>% #***THERE IS AN INF VALUE
  filter(kappa<30) %>% #***THERE IS AN OUTLIER
  spread(forest27_start,kappa) %>% 
  filter(is.na(matrix)==FALSE) %>% #***THERE ARE NA'S 
  filter(is.na(forest)==FALSE) #***THERE ARE NA'S

#Parametric and non-parametric test
t.test(von.mises.parameters.by.vegetation.spread$matrix,von.mises.parameters.by.vegetation.spread$forest)
#wilcox.test(von.mises.parameters.by.vegetation.spread$matrix,von.mises.parameters.by.vegetation.spread$fores)

#Summary of mean of von mises distribution by vegetal cover
tapply(von.mises.parameters.by.vegetation$mu,von.mises.parameters.by.vegetation$forest27_start,summary)

#Summary of kappa concentration parameter of von mises distribution by vegetal cover
tapply(von.mises.parameters.by.vegetation %>% filter(kappa!=Inf) %>% .$kappa,von.mises.parameters.by.vegetation %>% filter(kappa!=Inf) %>% .$forest27_start,summary)



#Graph of von mises distribution by vegetal cover
#par(mfrow=c(6,4))
#jpeg("Graphs/Von  mises distribution of angle parameter.jpg",quality=100,width=1000,height=700)
for (i in 1:nrow(von.mises.parameters)){
  
  #plot(tracking.database.unlisted %>% mutate(ta_=deg2rad(ta_)) %>% select(ta_) %>% .$ta_,dvmises(tracking.database.unlisted %>% mutate(ta_=deg2rad(ta_)) %>% select(ta_) %>% arrange(ta_) %>% .$ta_,as.numeric(von.mises.parameters[i,"kappa"])),col=i,type="l")
  #plot(tracking.database.unlisted %>% mutate(ta_=deg2rad(ta_)) %>% select(ta_) %>% .$ta_,data.frame(distribution=dvmises(tracking.database.unlisted %>% mutate(ta_=deg2rad(ta_)) %>% select(ta_) %>% .$ta_,as.numeric(von.mises.parameters[i,"kappa"]))) %>% filter(distribution!="Inf") %>% arrange(distribution),col=i,type="l")
  
  plot(tracking.database.unlisted %>% mutate(ta_=deg2rad(ta_)) %>% select(ta_) %>% .$ta_,dvmises(tracking.database.unlisted %>% mutate(ta_=deg2rad(ta_)) %>% select(ta_) %>% .$ta_,as.numeric(von.mises.parameters[i,"kappa"])),col=i)
  #par(new=TRUE)

#ifelse(i==nrow(von.mises.parameters),par(new=FALSE),par(new=TRUE))
  
}

#dev.off()
rm(borrar)
```


```{r}
#Graph of turning angle vs step length
tracking.database.unlisted %>%
  ggplot(aes(y=log_sl_,x=ta_)) +
  geom_point() + 
  geom_smooth()

tracking.database.unlisted %>%
  filter(sl_>0) %>% 
  ggplot(aes(y=log_sl_,x=ta_)) +
  geom_point() + 
  geom_smooth()

tracking.database.unlisted %>%
  filter(ta_==0) %>% 
  ggplot(aes(y=log_sl_)) +
  geom_boxplot() + 
  facet_wrap(~forest27_start)

```

#LM for differences between step length in patches

```{r,purl=FALSE}
#Merge variables of movement behavior with environmental variables of patches. #**Although now that I think about it, it would be better to have the environmental variables of a buffer of each step
tracking.database.unlisted<-freq.patches %>% 
  inner_join(tracking.database.unlisted,by=c("FREQ"="id")) %>% 
  inner_join(patches.info,by=c("PATCH"="Patch")) %>% 
  mutate(logpatch_size=log(patch_size)) 

tracking.database.unlisted %>% 
  select(FREQ,log_sl_,logpatch_size,percent_forest,elevation) %>% ggpairs(upper=list(continuous="points"),lower=list(continuous="cor"))


library("nlme")
#Model without random structure
summary(mod.1<-gls(log_sl_ ~logpatch_size+percent_forest+elevation,method = "REML", data = tracking.database.unlisted))


#GLMM nesting frequency
#mod.2<-lme(log_sl_~logpatch_size+percent_forest+elevation,random = ~1 | FREQ,data=d,method="REML")
#summary(mod.2)

#without patch size
#mod.3<-lme(log_sl_~percent_forest+elevation,random = ~1 | FREQ,data=d,method="REML")
#summary(mod.3)

#Without percent of forest
#mod.4<-lme(log_sl_~elevation,random = ~1 | FREQ,data=d,method="REML")
#summary(mod.4)

#library("MuMIn")
#Weights(AIC(mod.1,mod.2,mod.3,mod.4))

tracking.database.unlisted %>% 
  ggplot(aes(x=elevation,y=log_sl_)) +
  geom_point() + 
  geom_smooth(method="lm",col="red")
```



#Fit models
```{r}
#This was the original model, which used log_sl and sl in the same model. The authors did it that way, although it is weird that two variables that are transformed are used in the same model. I will use only one of them to fit the model
#m2 <- m2 %>% mutate(fit = map(ssf, ~ fit_issf(.,case_ ~ forest27_end + log_sl_ + sl_  + log_sl_:forest27_end + sl_:forest27_end + strata(step_id_))))

condensed.dataframe.subset <- condensed.dataframe.subset %>% 
  mutate(fit = map(ssf, ~ fit_issf(.,case_ ~ forest27_end + log_sl_ + cos(ta_)  + log_sl_:forest27_end + cos(ta_):forest27_end + strata(step_id_))))


#I usded another method to calculate this. Frequencies 432, 591, 672 and 910 gave a NA to habitat selection parameter. Those are birds that where only on forest or non-forested areas (except for 1 of them which is calculating good the parameter). However, they give an estimate of the shape and scale parameter of the step length
condensed.dataframe.subset.remaining2<-condensed.dataframe.subset.remaining[c(1,4,6,8,9,10),] %>% 
  mutate(fit = map(ssf, ~ fit_issf(.,case_ ~ forest27_end + log_sl_ + cos(ta_) + strata(step_id_),method="efron")))

#***I cannot run row 4,6,8,9,10
condensed.dataframe.subset.remaining <- condensed.dataframe.subset.remaining[c(2,3,5,7),] %>% 
  mutate(fit = map(ssf, ~ fit_issf(.,case_ ~ forest27_end + log_sl_ + cos(ta_) + strata(step_id_))))


condensed.dataframe.subset <- rbind(condensed.dataframe.subset,condensed.dataframe.subset.remaining,condensed.dataframe.subset.remaining2)
```


```{r}
#MAKE DATA BASES FOR ANALYSIS

#Make a data base with the values of each parameter. 
parameters.simulations <- data.frame(id.simulation=condensed.dataframe.subset$id) #*** IN THIS LINE I WOULD PUT THE NUMBER OF SIMULATIONS I WOULD LIKE TO DO, BUT NO I AM PUTTING THE ID OF THE BIRD SINCE EACH ONE HAS A SPECIFIC PARAMTER

for (i in 1:nrow(condensed.dataframe.subset)) {
  
  parameters.simulations$shape.step.length[[i]] <- sl_shape(condensed.dataframe.subset$fit[[i]])  #It uses a gamma distribution for step length. I think this is the mean. ***Understand why are they using a gamma distribution. HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE GAMMA DISTRIBUTION I WOULD LIKE TO SIMULATE
  
  parameters.simulations$scale.step.length[[i]] <- sl_scale(condensed.dataframe.subset$fit[[i]]) #It uses a gamma distribution for step length. I think this is the scale, which is part of what will determine the distribution ***Understand why are they using a gamma distribution. HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE GAMMA DISTRIBUTION I WOULD LIKE TO SIMULATE

  
  parameters.simulations$habitat.utilization[[i]] <- coef(condensed.dataframe.subset$fit[[i]])["forest27_endforest"] #***HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE HABITAT SELECTION COEFFICIENT I WOULD LIKE TO SIMULATE
  
}

#Make a splitted list with the id. of the simulation number
#parameters.simulations<-split(parameters.simulations,parameters.simulations$num.simulation)





#Make a data base with the values of each parameter. REMAINING
parameters.simulations.remaining <- data.frame(id.simulation=condensed.dataframe.subset.remaining$id) #*** IN THIS LINE I WOULD PUT THE NUMBER OF SIMULATIONS I WOULD LIKE TO DO, BUT NO I AM PUTTING THE ID OF THE BIRD SINCE EACH ONE HAS A SPECIFIC PARAMTER

for (i in 1:nrow(condensed.dataframe.subset.remaining)) {
  
  parameters.simulations.remaining$shape.step.length[[i]] <- sl_shape(condensed.dataframe.subset.remaining$fit[[i]])  #It uses a gamma distribution for step length. I think this is the mean. ***Understand why are they using a gamma distribution. HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE GAMMA DISTRIBUTION I WOULD LIKE TO SIMULATE
  
  parameters.simulations.remaining$scale.step.length[[i]] <- sl_scale(condensed.dataframe.subset.remaining$fit[[i]]) #It uses a gamma distribution for step length. I think this is the scale, which is part of what will determine the distribution ***Understand why are they using a gamma distribution. HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE GAMMA DISTRIBUTION I WOULD LIKE TO SIMULATE

  
  parameters.simulations.remaining$habitat.utilization[[i]] <- coef(condensed.dataframe.subset.remaining$fit[[i]])["forest27_endforest"] #***HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE HABITAT SELECTION COEFFICIENT I WOULD LIKE TO SIMULATE
  
}


parameters.simulations <- rbind(parameters.simulations,parameters.simulations.remaining)


#This chunk is for obtaining the coordinates of the focal patch from Adam's data base and then figuring out the patch id in the croppped labeled map. ***MAYBE HERE I CAN CREATE A DATA BASE WITH THE XY COORDINATES OF THE PATCHES WHERE I WOULD LIKE TO DO THE SIMULATIONS
#Import data base with information about patches and xy locations of the patch
patches.locations<-read.xlsx("Data bases/Information patches Costa Rica.xlsx",sheet=1)

#Select columns with patch and coordinates information
patches.locations<-patches.locations[,c("PATCH_ID","X","Y")]

#Import data base with information about frequencies with patches
frequencies.patches<-read.xlsx("Data bases/Frequencies patches.xlsx",sheet=1)

#MErge the patches where birds were sampled with xy information
frequencies.patches<-merge(frequencies.patches,patches.locations,by.x="PATCH",by.y="PATCH_ID",all=T)

#Remove data base
rm(patches.locations)

#Create an object with the land use raster map but labelled
land_use_raster_labeled<-ConnCompLabel(land_use_raster)

#I will make a list of the patches where the birds will be moving. ###***HERE I CAN MODIFY THE CODE SO THAT I CAN PUT ANY PATCH I WANT. FOR NOW I AM USING PATCHES WERE THE BIRDS WERE CAPTURED
#Make a list with the forest raster cropped to the extent of the animal that moved
structure <- list(id.freq=numeric(),forest.raster.cropped=list())

#Make a splitted list with the id. freq. ***HERE I COULD USE THE LAND_USE_RASTER (THIS IS, THE COMPLETE MAP OF THE LANDSCAPE BUT LABALED) TO DO THE LIST SO THAT I HAVE REPRESENTED EACH PATCH OF THE LANDSCAPE. aLTERNATIVELY, FOR MY THESIS I CAN LOCATE THE PATCH IN THE LAND_USE_RASTER BASED ON THE PATCHES.LOCATION OBJECT (WHICH HAS THE XY COORDINATES OF THE PATCH WHERE THE BIRD WAS CAPTURED, SEE BELOW) TO SELECT ONLY THOSE PATCHES AND DO THE SIMULATIONS ONLY IN THOSE PATCHES. I COULD USE THE frequencies.patches DATA BASE (WHERE I AM PLANNING TO PUT THE XY LOCATIONS OF THE PATCHES WHERE I WOULD LIKE TO DO THE SIMULATIONS) TO SPLIT IT AND THEN USE THAT INFORMATION TO DO THE SIMULATIONS
forest.raster.cropped<-split(condensed.dataframe.subset$id,condensed.dataframe.subset$id)

#Construct the list with the elements
for (i in 1:length(forest.raster.cropped)){
  
  #Copy the structure of the list I want
  forest.raster.cropped[[i]] <- structure
  
  #Put the id. freq. ***HERE I WOULD PUT THE PATCH ID. I THINK I AM PUTTING THE ID.FREQ BECAUSE IT IS BASED ON WHERE THE BIRD MOVED. ON THE FUTURE I WILL NOT NEED THIS BECAUSE I WILL HAVE THE XY COORDINATES OF THE PATCHES WHERE I WANT TO DO THE SIMULATION 
  forest.raster.cropped[[i]]$id.freq <- condensed.dataframe.subset$id[[i]] 
  
  #Obtain the x y values of the focal patch. ###HERE I AM USING THE INFORMATION FROM ADAM FROM THE COORDINATES WHERE THE BIRDS WHERE CAPTURED, BUT I CAN USE ANY XY COORDINATE WHERE I WANT TO DO THE SIMULATION AND THEN OBTAIN THE INFORMATION OF THE CELL NUMBER FOR THE COMPLETE MAP OR THE CROPPED MAP (NEXT LINES)
  forest.raster.cropped[[i]]$focal.patch.xy <- subset(frequencies.patches,frequencies.patches$FREQ==forest.raster.cropped[[i]]$id.freq)[,c("X","Y")]
  
  #Obtain the cell number from the xy cordinate from the complete raster map
  forest.raster.cropped[[i]]$focal.patch.label.complete.map <- land_use_raster_labeled[cellFromXY (land_use_raster_labeled, forest.raster.cropped[[i]]$focal.patch.xy)]
  
  #Crop the map to the area in which the animal moved. #****NOW I AM CROPPING THE MAP BASED ON THE PLACES WHERE THE BIRD MOVED, BUT I COULD CROP THE MAP BASED ON THE LOCATION OF THE PATCH WHERE I WANT TO DO THE SIMULATION
  forest.raster.cropped[[i]]$forest.raster.cropped <- crop(land_use_raster, amt::bbox(condensed.dataframe.subset$trk[[i]], spatial = TRUE, buff = 1e3))
  
  #Store movment kernel
  #forest.raster.cropped[[i]]$movement.kernel <- movement_kernel(parameters.simulations$scale.step.length[[i]], parameters.simulations$shape.step.length[[i]], forest.raster.cropped[[i]]$forest.raster.cropped)
  
  #Store habitat kernel
  #forest.raster.cropped[[i]]$habitat.kernel <- habitat_kernel(list(forest27 = parameters.simulations$habitat.kernel[[i]]), forest.raster.cropped[[i]]$forest.raster.cropped)
  
  #Sotre forest raster labaled.
  forest.raster.cropped[[i]]$forest.raster.cropped.labeled<-ConnCompLabel(forest.raster.cropped[[i]]$forest.raster.cropped)
  
  #Obtain the cell number from the xy cordinate from the cropped raster map. ***I HAVE THE CORRECT VALUES OF THE RASTERS, I ONLY NEED TO MODIFY THE CODE SO THAT IT WORKS WITH THIS MODIFICATION
  forest.raster.cropped[[i]]$focal.patch.label.cropped <- forest.raster.cropped[[i]]$forest.raster.cropped.labeled[cellFromXY (forest.raster.cropped[[i]]$forest.raster.cropped.labeled, forest.raster.cropped[[i]]$focal.patch.xy)]
  
    #Add a slot where I will put the environmental variables of the patch where the simulation is going to be made
  forest.raster.cropped[[i]]$landscape.variables <- frequencies.patches %>% 
    rename("Patch"="PATCH") %>% 
    inner_join(patches.info,by="Patch") %>% 
    filter(FREQ==forest.raster.cropped[[i]]$id.freq) %>% 
    distinct()
  
}



rm(structure)
```


```{r}
#Graph to see if parameters varied with environmental variables
parameters.simulations %>% 
  inner_join(frequencies.patches %>% 
               mutate(Patch=PATCH,
                      id.simulation=FREQ) %>% 
               select(Patch,id.simulation),by="id.simulation") %>% 
  inner_join(patches.info,by="Patch") %>% 
  mutate(log.patch.size=patch_size) %>% 
  select(-c(patch_size,id.simulation,Patch)) %>% 
  ggpairs(upper=list(continuous="smooth"),lower=list(continuous="cor"))
```


```{r}

for (i in 1:length(forest.raster.cropped)){
 
  map<-land_use_raster_labeled
  map[map!=forest.raster.cropped[[i]]$focal.patch.label.complete.map]<-0.5
  plot(map)
   
  
}

```



```{r}
#Make graph with shape and scale of gamma distribution of original birds
jpeg("Graphs/Gamma distribution of shape parameter.jpg",quality=100,width=1000,height=700)

#pgamma with original shape and scale parameters per bird
for (i in 1:nrow(parameters.simulations)){
plot(c(min(tracking.database.unlisted$sl_):max(tracking.database.unlisted$sl_)), pgamma(min(tracking.database.unlisted$sl_):max(tracking.database.unlisted$sl_), shape = parameters.simulations[i,"shape.step.length"], scale = parameters.simulations[i,"scale.step.length"]), type = "l",col=i,ylim=c(0,1),xlab="Dispersal distance (m)",ylab="Probability")

ifelse(i==nrow(parameters.simulations),par(new=FALSE),par(new=TRUE))
}

dev.off()

#See if there is a relationship between shape and scale parameter
parameters.simulations %>% 
  ggplot(aes(x=shape.step.length,y=scale.step.length)) + 
  geom_point() +
  geom_smooth(method="lm")

#Model to see if there is a relationship between shape and scale parameter
summary(mod.1 <- lm(shape.step.length~scale.step.length,data=parameters.simulations))

summary(mod.2<-lme(shape.step.length~scale.step.length,random = ~1 | PATCH,data=parameters.simulations %>% rename("FREQ"="id.simulation") %>%  inner_join(freq.patches,by="FREQ"),method="REML"))

scale.parameter.modification <- parameters.simulations %>% 
  mutate(scale.original=scale.step.length,
    scale.lower=quantile(scale.step.length,probs=0.05),
         scale.median=median(scale.step.length),
         scale.upper=quantile(scale.step.length,probs=0.95))
#NO RELATIONSHIP FOUND. 

#Boxplot of scale parameter without including outlier
scale.parameter.modification %>% 
  filter(scale.step.length<200) %>% 
  ggplot(aes(y=scale.step.length)) +
  geom_boxplot()

#Ummary of scale parameter without including outlier
scale.parameter.modification %>% 
  filter(scale.step.length<200) %>% 
  summary()

#Graph of scale paramter of original birds but fixing compard with tthe 0.05, 0.5 and 0.95 quantiles of the originial scale
par(mfrow=c(2,2))
for(k in (ncol(scale.parameter.modification)-3):ncol(scale.parameter.modification)){
for (i in 1:nrow(scale.parameter.modification)){
plot(c(min(tracking.database.unlisted$sl_):max(tracking.database.unlisted$sl_)), pgamma(min(tracking.database.unlisted$sl_):max(tracking.database.unlisted$sl_), shape = scale.parameter.modification[i,"shape.step.length"], scale = scale.parameter.modification[i,k]), type = "l",col=i,ylim=c(0,1),xlab="Dispersal distance (m)",ylab="Probability",main=names(scale.parameter.modification[k]))

ifelse(i==nrow(parameters.simulations),par(new=FALSE),par(new=TRUE))
}
}

```

```{r}
#Make data frame that will include all the combinations of the parameters I would like to simulate per patch
parameters.simulations.model <- data.frame(shape.step.length=quantile(parameters.simulations$shape.step.length,probs=c(0.05,0.5,0.95)),
             scale.step.length=median(parameters.simulations$scale.step.length),
             habitat.utilization=quantile(parameters.simulations %>% filter(habitat.utilization>-600) %>% select(habitat.utilization) %>% .$habitat.utilization,probs=c(0.05,0.5,0.95))) %>% 
  expand.grid() %>% #Make all the combinations
  distinct() %>%  #Double check that there are no repeated values
  mutate(id.simulation=1:nrow(.))


#Make a data frame with the shape parameters I selected and with different scale parameters (quantiles 0.05,0.5,0.95)
scale.parameter.modification <- scale.parameter.modification %>% 
  mutate(shape.step.length.lower.quantile=quantile(parameters.simulations$shape.step.length,probs=0.05),
         shape.step.length.median=quantile(parameters.simulations$shape.step.length,probs=0.5),
         shape.step.length.higher.quantile=quantile(parameters.simulations$shape.step.length,probs=0.95)) %>% 
  select(-c(id.simulation,shape.step.length,scale.step.length,habitat.utilization,scale.original)) %>% 
  distinct() 

#Graph the different shape parameters I selected for the simulation versus the different scale parameters
par(mfrow=c(2,2))
for(k in 4:6){
for (i in 1:3){
plot(c(min(tracking.database.unlisted$sl_):max(tracking.database.unlisted$sl_)), pgamma(min(tracking.database.unlisted$sl_):max(tracking.database.unlisted$sl_), shape = scale.parameter.modification[,k], scale = scale.parameter.modification[,i]), type = "l",col=i,ylim=c(0,1),xlab="Dispersal distance (m)",ylab="Probability",main=names(scale.parameter.modification[k]))

ifelse(i==3,par(new=FALSE),par(new=TRUE))
}
}

#I DO NOT SEE ANY DRASTIC CHANGES, SO I COULD USE THE MEDIAN OF THE SCALE PARAMETER

rm(scale.parameter.modification)
```



### Plot

```{r}

#Obtain the parameters with their confidence internvals
graph.parameters.database <- condensed.dataframe.subset %>% mutate(coef = map(fit, ~ broom::tidy(.x$model))) %>%
select(id, coef) %>% unnest %>%
mutate(id = factor(id),
       term=if_else(term=="forest27_endforest","Habitat selection",term),
       term=if_else(term=="log_sl_","Log step length",term),
       term=if_else(term=="cos(ta_)","Turning angle",term),
       term=if_else(term=="forest27_endforest:log_sl_","Log step length by habitat",term),
       term=if_else(term=="forest27_endforest:cos(ta_)","Turning angle by habitat",term)) %>% group_by(term) %>%
summarize(
mean = mean(estimate),
ymin = mean - 1.96 * sd(estimate),
ymax = mean + 1.96 * sd(estimate)
)

graph.parameters.database$x <- 1:nrow(graph.parameters.database)
data <- condensed.dataframe.subset %>% mutate(coef = map(fit, ~ broom::tidy(.x$model))) %>%
select(id, coef) %>% unnest %>% 
mutate(id = factor(id)) #filter(conf.low!=-Inf)  %>% #I added this line since there are -inf values on the data set 

#Plot small version of the plot. 
#I THINK THAT THE VALUE OF THE PARAMETERS HAVE THE FOLLOWING MEANING:
#HABITAT SELECTION: SMALL VALUES MEAN THAT THAT THEY ARE CHOOSING MORE NON-FORESTED POINTS THAN FORESTED.
#STEP LENGTH:IT IS USING A GAMMA DISTRIBUTION AND IT IS USED TO ADJUST THE SHAPE AND SCALE OF THE DISTRIBUTION. I THINK I WOULD MODIFY THE SHAPE, SINCE LOW VALUES MAKE A RIGHT SKEWED DISTRIBUTION (SMALL STEP LENGTHS AND RARE LONG STEP LENGHTS) AND HIGH VALUES MAKE THE DISTRIBUTION SHIFT TO THE LEFT (LONGER STEP LENGTHS ARE MORE FREQUENT)
#TURNING ANGLE: IT USES A VON-MISES DISTRIBUTION. LOW VALUES MAKE A MORE UNIFORM DISTRIBUTION, WHILE HIGH VALUES CONCENTRATE THE DISTRIBUTION ON THE 0 ANGLE. 
data %>% 
  filter(conf.low!=-Inf) %>% 
  filter(id!=973) %>% 
  mutate(term=if_else(term=="forest27_endforest","Habitat selection",term),
         term=if_else(term=="log_sl_","Log step length",term),
         term=if_else(term=="cos(ta_)","Turning angle",term),
         term=if_else(term=="forest27_endforest:log_sl_","Log step length by habitat",term),
         term=if_else(term=="forest27_endforest:cos(ta_)","Turning angle by habitat",term)) %>% 
  ggplot(., aes(x = term, y = estimate, group = id, col = id)) +
# geom_rect(mapping = aes(xmin = x - .4, xmax = x + .4, ymin = ymin,
# ymax = ymax, y = mean), data = d2 %>% mutate(x = as.numeric(x)), inherit.aes = FALSE,
# fill = "grey90") +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high),
position = position_dodge(width = 0.7), size = 0.8)  +
  geom_errorbar(data = graph.parameters.database, aes(x = term, y = mean, ymin = mean, ymax = mean), inherit.aes = FALSE,
size = 1) +
geom_hline(yintercept = 0, lty = 2) +
labs(x = "Parameters", y = "Relative Selection Strength") +
theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
    #+
#scale_x_discrete(labels = c("Developed (open)", "Developed (other)", "Natural", "Crops","Other","Step length"))
#p1
#ggsave("img/fig_all_animals.pdf", width = 24, height = 12, units = "cm")
#ggsave("fig_all_animals_parameters_luis.pdf", width = 24, height = 12, units = "cm")
ggsave("Graphs/Multi bird parameters.jpg")



#Make a density plot of the parameters
data %>%
  mutate(term=if_else(term=="forest27_endforest","Habitat selection",term),
         term=if_else(term=="log_sl_","Log step length",term),
         term=if_else(term=="cos(ta_)","Turning angle",term),
         term=if_else(term=="forest27_endforest:log_sl_","Log step length by habitat",term),
         term=if_else(term=="forest27_endforest:cos(ta_)","Turning angle by habitat",term)) %>% 
  ggplot(aes(x=estimate)) + 
  geom_histogram(aes(y=..density..),colour="black", fill="white") +
  geom_density(alpha=.2, fill="#FF6666") +
  facet_wrap(~term,scales="free")
ggsave("Graphs/Multi bird density plot parameters.jpg")
  
tapply(data$estimate,data$term,summary)
tapply(data$estimate,data$term,sd)

#Summary of habitat selection parameter without the outlier
data %>% 
  filter(term=="forest27_endforest" & estimate>min(estimate)) %>% 
  select(estimate) %>% 
  summary()

#Save workspace for simulation
#save.image("worksapce_calculon.RData")
#rm(graph.parameters.database)
```

```{r}
#Plot points of all sampled patches
library("viridis")
 plot(land_use_raster)
for (i in 1:length(forest.raster.cropped)){
 
 
  points(forest.raster.cropped[[i]]$focal.patch.xy,
         col=plasma(length(forest.raster.cropped)[i],0.4),pch=16)
  
}
 
 legend("topright",legend=1:length(forest.raster.cropped),col=plasma(length(forest.raster.cropped)),pch=16,ncol=3)
 
 
 #Plot point of a specific sampled patch
  plot(land_use_raster)
 
  points(forest.raster.cropped[[11]]$focal.patch.xy,pch=16)

```


Run replicate simulations:

```{r}

#Load workspace for simulation modelling
#load("simulation_modelling_workspace.RData")
#Soruce simulation functions
#source("SSF_simulation_functions_all_birds.R") #This is when it is in the super computer
source("SSF simulation functions all birds.R")

#Set up the number of simulations per patch and also number of simulations per starting point
num.sim.points.per.patch<-50
num.sim.per.point<-1

#Make a list of the
results.simulations.list <- split(parameters.simulations.model$id.simulation,parameters.simulations.model$id.simulation)

registerDoParallel(detectCores())
#registerDoParallel(10)

#1,2,4,8,13,15,17,18
#for (i in 1:nrow(parameters.simulations)){

  results.simulations.list <- foreach (i= c(14),#c(1,2,4,9,11,13,14), 11
                                .packages=c("amt","raster")) %dopar% {

simulate.movement(focal.patch=forest.raster.cropped[[i]]$focal.patch.label.cropped,
                  tot.num.minutes=60,
                  fix.rate=5,
                  parameters.simulations=parameters.simulations.model,
                  num.sim.points.per.patch=num.sim.points.per.patch, #I tried to only put a number and then save the number I put with the name of the variable but I could not do it, so that is why I specifya outside the function the value and store in in the variable
                  num.sim.per.point=num.sim.per.point, #I tried to only put a number and then save the number I put with the name of the variable but I could not do it, so that is why I specifya outside the function the value and store in in the variable
                  map.full=land_use_raster,
                  map.cropped=forest.raster.cropped[[i]]$forest.raster.cropped,
                  map.cropped.labeled=forest.raster.cropped[[i]]$forest.raster.cropped.labeled,
                  landscape.variables=forest.raster.cropped[[i]]$landscape.variables,
                  name.output.list=raw.results.emigration) #Remember now that the output data frame is results.simulations.list


  
}



stopImplicitCluster()

#Save results
#save.image("borrar.Rdata")

#dput(results.simulations.list,"results.simulations.list")
```

```{r}
results.simulations.list <- dget("results.simulations.list")
```


```{r}
#Obtain the information from the list in a data base. 
#raw.dataframe(#focal.patch=focal.patch,
 # name.input.database=results.simulations2,
              #name.output.dataframe=raw.formated.results.emigration)

#***ADDED THIS CHUNK OF CODE. IT IS THE CODE I HAVE FOR THE FUNCTION raw.dataframe BUT OUTSIDE IS WORKING
  #Create a data frame with 1 row and the number of columns so that it matches the data frame 
  #I generated for each simulation (in this case is called results.simulations2). I am using the
  #first element of the list as a molde
  results.simulations.df<-data.frame(matrix(0,
                                          ncol=ncol(results.simulations.list[[1]][[1]][[1]][[1]][[1]]),
                                          nrow=1)) 
  
  #Name columns
  names(results.simulations.df)<-names(results.simulations.list[[1]][[1]][[1]][[1]][[1]])


  #Paste all data bases
  for (z in 1:length(results.simulations.list)){
    
    for(a in 1:length(results.simulations.list[[z]])){
      
      for (g in 1:length(results.simulations.list[[z]][[a]])){
        
        for (l in 1:length(results.simulations.list[[z]][[a]][[g]]))
          
          for (q in 1:length(results.simulations.list[[z]][[a]][[g]][[l]]))
            
      {
        
        df<-results.simulations.list[[z]][[a]][[g]][[l]][[q]]
        
        results.simulations.df<-rbind(df,results.simulations.df)
        
      }
    }
  }
  }
  
  
  #Delete last observation which has nothing
  results.simulations.df<-results.simulations.df[-nrow(results.simulations.df),]


```



```{r}
#Obtain data base with values aggregated by time and showing the proportion of fruit in each faith by time. ###***I DO NOT KNOW WELL HOW AM I GOING TO DO THIS ANALYSIS, SO I DO NOT KNOW WELL THE STRUCTURE OF THE DATA BASE. sPECIFICALLY, I DO NOT KNOW IF I HAVE TO INCLUDE THE PARAMETERS VALUES

results.emigration <- final.database(name.input.database=results.simulations.df,
               name.output.dataframe=results.emigration) %>% 
  filter(time==20 | time==40 | time==60) #Subsetting the times that I am interested
```

```{r}
#Anaylsis of the porportion of fruits in the landscape
results.emigration %>% 
  select(-c(focal.patch,patch.id.adam,matrix,new.patch,same.patch)) %>% 
  ggpairs(upper=list(continuous="cor"),lower=list(continuous="smooth"))

results.emigration<-results.emigration %>% 
  mutate(log.patch.size=log(patch.size))

#Proportion of fruits in the same patch
#Model without random structure
library("nlme")
summary(mod.1<-gls(asin(sqrt(prop.same.patch)) ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),method = "REML", data = results.emigration %>% mutate(id=paste(patch.id.adam,focal.patch))))


#GLMM nesting frequency
summary(mod.2<-lme(asin(sqrt(prop.same.patch)) ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),random = ~1 | id,data=results.emigration %>% mutate(id=paste(patch.id.adam,focal.patch),method="REML")))

#Continue with LMM
#Without step length
summary(mod.3 <- update(mod.2,.~. -scale(param.shape.step.length)))

#Without patch size
summary(mod.4 <- update(mod.3,.~. -scale(percent.forest)))

#Without percent forest
summary(mod.5 <- update(mod.4,.~. -scale(log.patch.size)))

#Without elevation
summary(mod.6 <- update(mod.5,.~. -scale(elevation)))


#Plots
results.emigration %>% 
  ggplot(aes(x=param.habitat.utilization,y=prop.same.patch)) +
  geom_point() +
  geom_smooth(method="lm")

results.emigration %>% 
  ggplot(aes(x=time,y=prop.same.patch)) +
  geom_point() +
  geom_smooth(method="lm")



#Proportion of fruits in the matrix
#Model without random structure
library("nlme")
summary(mod.1<-gls(asin(sqrt(prop.matrix)) ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),method = "REML", data = results.emigration %>% mutate(id=paste(patch.id.adam,focal.patch))))


#GLMM nesting frequency
summary(mod.2<-lme(asin(sqrt(prop.matrix)) ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),random = ~1 | id,data=results.emigration %>% mutate(id=paste(patch.id.adam,focal.patch),method="REML")))

#Continue with LMM
#Without step length
summary(mod.3 <- update(mod.2,.~. -scale(param.shape.step.length)))

#Without patch size
summary(mod.4 <- update(mod.3,.~. -scale(percent.forest)))

#Without percent forest
summary(mod.5 <- update(mod.4,.~. -scale(elevation)))

#Without elevation
summary(mod.6 <- update(mod.5,.~. -scale(log.patch.size)))





#Proportion of fruits in a new patch
#Model without random structure
library("nlme")
summary(mod.1<-gls(asin(sqrt(prop.new.patch)) ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),method = "REML", data = results.emigration %>% mutate(id=paste(patch.id.adam,focal.patch))))


#GLMM nesting frequency
summary(mod.2<-lme(asin(sqrt(prop.new.patch)) ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),random = ~1 | id,data=results.emigration %>% mutate(id=paste(patch.id.adam,focal.patch),method="REML")))

anova(mod.1,mod.2)

#Continue with LMM
#Without step length
summary(mod.3 <- update(mod.2,.~. -scale(param.shape.step.length)))

#Without patch size
summary(mod.4 <- update(mod.3,.~. -scale(log.patch.size)))

#Without percent forest
summary(mod.5 <- update(mod.4,.~. -scale(elevation)))

#Without elevation. #MArginally significant, but I will take it out
summary(mod.6 <- update(mod.5,.~. -scale(param.habitat.utilization)))

results.emigration %>% 
  filter(prop.new.patch>0) %>% 
  group_by(percent.forest) %>% 
  summarise(number=n())


results.emigration %>% 
  ggplot(aes(x=percent.forest,y=prop.new.patch)) +
  geom_point() +
  geom_smooth(method="lm")

results.emigration %>% 
  ggplot(aes(x=time,y=prop.new.patch)) +
  geom_point() +
  geom_smooth(method="lm")
```

```{r}
#LMM for testing differences in the proportion of seeds that were dispersed to different fates
test.proportions<-results.emigration %>% 
  mutate(id=paste(focal.patch,patch.id.adam,sep=".")) %>% 
  select(id,prop.same.patch,prop.matrix,prop.new.patch)  %>% 
  gather(fate,proportion,prop.same.patch:prop.new.patch) %>% 
  lme(asin(sqrt(proportion))~fate,random = ~1 | id,data=.)

summary(test.proportions)

#Graph of proportion of seed by fate
results.emigration %>% 
  select(prop.same.patch,prop.matrix,prop.new.patch) %>% 
  gather(fate,proportion) %>% 
  group_by(fate) %>% 
  summarise(mean.prop=mean(proportion),
            std.dev=sd(proportion),
            std.error=sd(proportion)/sqrt(n()),
            CI.low=mean(proportion)-2*sd(proportion)/sqrt(n()),
            CI.high=mean(proportion)+2*sd(proportion)/sqrt(n())) %>% 
  ungroup() %>%  
  ggplot(aes(x=factor(fate,level=c("prop.same.patch","prop.matrix","prop.new.patch")),y=mean.prop)) +
  geom_col() +
  geom_errorbar(aes(ymin=mean.prop-std.error, ymax=mean.prop+std.error), width=.2, position=position_dodge(.9)) +
  scale_x_discrete(labels=c("Focal patch", "Matrix", "New patch")) +
  theme(legend.position = "none") +
  xlab("Fate") +
  ylab("Mean proportion of seeds")

ggsave("Graphs/Proportion of seeds by fate.jpg")

rm(test.proportions)
```


```{r}
##Obtain the dispersal distance for each fix rate
dispersal.distance(#focal.patch=focal.patch,
                   name.input.database=results.simulations.list)
```

```{r}
#Obtain the information from the list in a data base including the seed dispersal distance
#raw.dataframe(#for.seed.dispersal="Y",
                #focal.patch=focal.patch,
                #name.input.database=results.simulations2,
                #name.output.dataframe=raw.results.emigration.dispersal.distance)  


###ADDED THIS CODE SINCE THE FUNCTION IS NOT WORKING
#Create a data frame with 1 row and the number of columns so that it matches the data frame 
  #I generated for each simulation (in this case is called results.simulations2). I am using the
  #first element of the list as a molde
  results.simulations.dispersal.distance.df<-data.frame(matrix(0,
                                          ncol=ncol(results.simulations.list[[1]][[1]][[1]][[1]][[1]]),
                                          nrow=1)) 
  
  #Name columns
  names(results.simulations.dispersal.distance.df)<-names(results.simulations.list[[1]][[1]][[1]][[1]][[1]])
  

  #Paste all data bases
  for (z in 1:length(results.simulations.list)){
    
    for(a in 1:length(results.simulations.list[[z]])){
      
      for (g in 1:length(results.simulations.list[[z]][[a]])){
        
        for (l in 1:length(results.simulations.list[[z]][[a]][[g]]))
          
          for (q in 1:length(results.simulations.list[[z]][[a]][[g]][[l]]))
      {
        
        df<-results.simulations.list[[z]][[a]][[g]][[l]][[q]]
        
        results.simulations.dispersal.distance.df<-rbind(df,results.simulations.dispersal.distance.df)
        
      }
    }
  }
  }
  
  
  #Delete last observation which has nothing
  results.simulations.dispersal.distance.df<-results.simulations.dispersal.distance.df[-nrow(results.simulations.dispersal.distance.df),]
  


```

```{r,purl=FALSE}
#ANALYZE PARAMETERS VERSUS DISPERSAL DISTANCE

#Summary of dispersal distance
summary(results.simulations.dispersal.distance.df$dispersal.distance)

#Boxplot of dispersal distance
results.simulations.dispersal.distance.df %>% 
  ggplot(aes(y=dispersal.distance)) +
  geom_boxplot()

#Make a data frame with log dispersal distance in long format
borrar <- results.simulations.dispersal.distance.df %>%
  select(same.patch,matrix,new.patch,dispersal.distance) %>% 
    mutate(log.dispersal.distance=log(dispersal.distance+1)) %>% 
  gather(fate,yes,same.patch:new.patch) %>% 
  filter(yes==1)

#Boxplot of seed dispersal distance by fate
borrar %>% 
  ggplot(aes(y=dispersal.distance)) +
  geom_boxplot() +
  facet_wrap(~fate)

#Boxplot of log seed dispersal distance by fate
borrar %>% 
  filter(fate!="matrix") %>% 
  ggplot(aes(x=factor(fate,levels=c("same.patch","new.patch")),y=log.dispersal.distance)) +
  geom_boxplot() +
  xlab("Fate") +
  ylab("Log seed dispersal disteance") +
  scale_x_discrete(labels=c("Focal patch","New patch"))

ggsave("Graphs/Seed dispersal distance by fate.jpg")

#Summary of seed dispersal distance by fate
borrar %>% 
  filter(fate!="matrix") %>% 
  select(dispersal.distance) %>% 
  summary()
tapply(borrar$dispersal.distance,borrar$fate,summary)

#Pair plot of seed dispersal distance only if it landed on forest
results.simulations.dispersal.distance.df<-results.simulations.dispersal.distance.df %>% 
  mutate(log.patch.size=log(patch.size),
         log.dispersal.distance=log(dispersal.distance+1)) 

results.simulations.dispersal.distance.df%>% 
  filter(same.patch==1 | new.patch==1) %>% #This only considers seed dispersal to places where it is likely that it will germinate
  select(log.dispersal.distance,param.shape.step.length,param.habitat.utilization,time,log.patch.size,percent.forest,elevation) %>%
  ggpairs(upper=list(continuous="smooth"),lower=list(continuous="cor"))


#Model without random structure
#library("nlme")
summary(mod.1<-gls(log.dispersal.distance ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),method = "REML", data = results.simulations.dispersal.distance.df %>% 
  filter(same.patch==1 | new.patch==1)) %>% mutate(id=paste(patch.id.adam,focal.patch),
                                                            log.dispersal.distance=log(dispersal.distance+1)))


#GLMM nesting frequency
summary(mod.2<-lme(log.dispersal.distance ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),random = ~1 | id,data=results.simulations.dispersal.distance.df %>% 
  filter(same.patch==1 | new.patch==1) %>% mutate(id=paste(patch.id.adam,focal.patch),
                                                            log.dispersal.distance=log(dispersal.distance+1),method="REML")))

#Continue with LMM
#Without habitat utilization
summary(mod.3 <- update(mod.2,.~. -scale(elevation)))

#Without habitat utilization
summary(mod.4 <- update(mod.3,.~. -scale(param.shape.step.length)))

#Without habitat utilization
summary(mod.5 <- update(mod.4,.~. -scale(log.patch.size)))






#Seed dspersal distance within the same patch
results.simulations.dispersal.distance.df %>% 
  filter(same.patch==1) %>% #This only considers seed dispersal to places where it is likely that it will germinate
  select(log.dispersal.distance,param.shape.step.length,param.habitat.utilization,time,log.patch.size,percent.forest,elevation) %>%
  ggpairs(upper=list(continuous="smooth"),lower=list(continuous="cor"))



#Model without random structure
#library("nlme")
summary(mod.1<-gls(log.dispersal.distance ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),method = "REML", data = results.simulations.dispersal.distance.df %>% 
  filter(same.patch==1)) %>% mutate(id=paste(patch.id.adam,focal.patch),
                                                            log.dispersal.distance=log(dispersal.distance+1)))


#GLMM nesting frequency
summary(mod.2<-lme(log.dispersal.distance ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),random = ~1 | id,data=results.simulations.dispersal.distance.df %>% 
  filter(same.patch==1) %>% mutate(id=paste(patch.id.adam,focal.patch),
                                                            log.dispersal.distance=log(dispersal.distance+1),method="REML")))

#Continue with LMM
#Without habitat utilization
summary(mod.3 <- update(mod.2,.~. -scale(elevation)))

#Without habitat utilization
summary(mod.4 <- update(mod.3,.~. -scale(log.patch.size)))

#Without habitat utilization
summary(mod.5 <- update(mod.4,.~. -scale(param.shape.step.length)))





results.simulations.dispersal.distance.df %>% 
  filter(new.patch==1) %>% #This only considers seed dispersal to places where it is likely that it will germinate
  select(log.dispersal.distance,param.shape.step.length,param.habitat.utilization,time,log.patch.size,percent.forest,elevation) %>%
  ggpairs(upper=list(continuous="smooth"),lower=list(continuous="cor"))


#Model without random structure
#library("nlme")
summary(mod.1<-gls(log.dispersal.distance ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),method = "REML", data = results.simulations.dispersal.distance.df %>% 
  filter(new.patch==1)) %>% mutate(id=paste(patch.id.adam,focal.patch),
                                                            log.dispersal.distance=log(dispersal.distance+1)))


#GLMM nesting frequency
summary(mod.2<-lme(log.dispersal.distance ~scale(param.shape.step.length) + scale(param.habitat.utilization) + scale(time) + scale(log.patch.size) + scale(percent.forest) + scale(elevation),random = ~1 | id,data=results.simulations.dispersal.distance.df %>% 
  filter(new.patch==1) %>% mutate(id=paste(patch.id.adam,focal.patch),
                                                            log.dispersal.distance=log(dispersal.distance+1),method="REML")))

#Continue with LMM
#Without habitat utilization
summary(mod.3 <- update(mod.2,.~. -scale(param.shape.step.length)))

#Without habitat utilization
summary(mod.4 <- update(mod.3,.~. -scale(percent.forest)))

#Without habitat utilization
summary(mod.5 <- update(mod.4,.~. -scale(log.patch.size)))

#Without habitat utilization
summary(mod.6 <- update(mod.5,.~. -scale(time)))


results.simulations.dispersal.distance.df %>% 
  ggplot(aes(x=time,y=dispersal.distance,group=time)) + 
  geom_boxplot() +
  geom_smooth(method="lm")

```



#Immigration


```{r}

load("borrar.RData")
#for (i in 1:length(forest.raster.cropped)){
for (i in c(1,2,14)){ #not included: 4,9,11,13
start <- Sys.time()
  print(paste("Start: ",start))
  
#Crop map using the buffer function at the end
#Crop the map to the extent I want
#Copy cropped map with labels that I used before
forest.raster.cropped[[i]]$focal.patch.label.cropped.immigration<-forest.raster.cropped[[i]]$forest.raster.cropped.labeled

#Patches that are not part of the focal patch will be set to NA
forest.raster.cropped[[i]]$focal.patch.label.cropped.immigration[]<-replace(forest.raster.cropped[[i]]$focal.patch.label.cropped.immigration[], forest.raster.cropped[[i]]$focal.patch.label.cropped.immigration[] != forest.raster.cropped[[i]]$focal.patch.label.cropped, NA)

#I need to know the cells to obtain the coordinates from the cropped map so that I can use the complete map and make the buffer
#Obtain coordinates from cell
#xy.focal.patch<-xyFromCell(forest.raster_c_labeled_immigration,which(forest.raster_c_labeled_immigration[] == focal.patch)[1])

#I will set it to 1500 m while I analyze the data 
max.dist.home.range<-750 #***CHECK: I think it is not selecting the 1500 m radius, it is selecting more. Check it later

#LAbel the complete forest map
#forest.raster_labeled<-ConnCompLabel(land_use)

#Find focal patch on the complete map
forest.raster.cropped[[i]]$cell.focal.patch.complete.map <- cellFromXY(land_use_raster_labeled,forest.raster.cropped[[i]]$focal.patch.xy)

#Patches that are not part of the focal patch will be set to NA 
forest.raster.cropped[[i]]$forest.raster_labeled_immigration<-land_use_raster_labeled
forest.raster.cropped[[i]]$forest.raster_labeled_immigration[forest.raster.cropped[[i]]$forest.raster_labeled_immigration != forest.raster.cropped[[i]]$forest.raster_labeled_immigration[forest.raster.cropped[[i]]$cell.focal.patch.complete.map]]<-NA

#Checking that I am selecting the right patch
#plot(land_use)
#plot(forest.raster_c_labeled_immigration, add=TRUE, col="red")

#Mke a buffer using the maximum home range distance
Buffer <- buffer(forest.raster.cropped[[i]]$forest.raster_labeled_immigration, width=max.dist.home.range)

#Plot to double check
#plot(Buffer)
#plot(forest.raster_c_labeled_immigration, add=TRUE, col="red")

#Crop the map to obtain the information of the extent
forest.raster.cropped[[i]]$immigration.map <- forest.raster.cropped[[i]]$focal.patch.label.cropped.immigration * Buffer

#Crop map to the extent of the buffer
forest.raster.cropped[[i]]$immigration.map<-crop(land_use_raster,extent(forest.raster.cropped[[i]]$immigration.map@extent))
forest.raster.cropped[[i]]$immigration.map.labeled<-crop(land_use_raster_labeled,extent(forest.raster.cropped[[i]]$immigration.map@extent))


#Obtain patch code of the croped map
forest.raster.cropped[[i]]$focal.patch.immigration<-forest.raster.cropped[[i]]$immigration.map.labeled[cellFromXY(forest.raster.cropped[[i]]$immigration.map.labeled,forest.raster.cropped[[i]]$focal.patch.xy)]

#Obtain all the patches id from the croped map
forest.raster.cropped[[i]]$patches.immigration<-unique(forest.raster.cropped[[i]]$immigration.map.labeled[])

#Select all patches except the one with the focal patch
forest.raster.cropped[[i]]$patches.immigration<-subset(forest.raster.cropped[[i]]$patches.immigration,forest.raster.cropped[[i]]$patches.immigration>0 & forest.raster.cropped[[i]]$patches.immigration!=forest.raster.cropped[[i]]$focal.patch.immigration)

print(i)
end <- Sys.time()
print(paste("Time ",round(end-start,2)))

}

rm(Buffer)


```

Run replicate simulations:

```{r}

source("SSF simulation functions.R")

#This function simlates movement behavior of an animal and needs the following information 
#focal.patch: the patches where the simulations will be made
#focal.patch.immigration: this is the focal patch that indicates te patch where the seed should land to be considered an immigrated seed 
#fix.rate: the time at which each point will be considered
#num.sim.points.per.patch: number of simulations that will be made starting from each focal patch
#num.sim.per.point: number of simulations that will be made per starting point
#map.full: full map with vegetation cover
#map.cropped: vegetation map cropped to the area where the simulation is going to be made
#map.cropped.labeled: same as map.cropped but instead of having vegetation cover id it has patch id for each forest patch
#name.output.dataframe: the name of the data base generated 


#Set up the number of simulations per patch and also number of simulations per starting point
num.sim.points.per.patch<-1
num.sim.per.point<-1

#Make a list of the
results.simulations.list.immigration <- split(parameters.simulations.model$id.simulation,parameters.simulations.model$id.simulation)

registerDoParallel(detectCores())
#registerDoParallel(10)

#1,2,4,8,13,15,17,18
#for (i in 1:nrow(parameters.simulations)){

  results.simulations.list.immigration <- foreach (i= c(1), #c(1,2,14), #c(1,2,4,9,11,13,14),
                                .packages=c("amt","raster")) %dopar% {

simulate.movement(focal.patch=forest.raster.cropped[[i]]$patches.immigration,
                  focal.patch.immigration=forest.raster.cropped[[i]]$focal.patch.immigration,
                  tot.num.minutes=5,
                  fix.rate=5,
                  num.sim.points.per.patch=num.sim.points.per.patch, #I tried to only put a number and then save the number I put with the name of the variable but I could not do it, so that is why I specifya outside the function the value and store in in the variable
                  num.sim.per.point=num.sim.per.point, #I tried to only put a number and then save the number I put with the name of the variable but I could not do it, so that is why I specifya outside the function the value and store in in the variable
                  map.full=land_use_raster,
                  map.cropped=forest.raster.cropped[[i]]$immigration.map,
                  map.cropped.labeled=forest.raster.cropped[[i]]$immigration.map.labeled,
                  landscape.variables=forest.raster.cropped[[i]]$landscape.variables,
                  name.output.list=raw.results.immigration)
                                  
                                }
  

  
  stopImplicitCluster()
  
  
```


Plot the map and add simulated paths:
```{r}

source("SSF simulation functions.R")
map.simulations(focal.patch=patches.immigration,
                num.sim.points.per.patch=num.sim.points.per.patch,
                num.sim.per.point=num.sim.per.point,
                dataframe.results=raw.results.immigration,
                offset=2300,
                map.full=land_use)

#ADD CODE TO HIGHLIGHT FOCAL PATCH 

```

#Format the output data base

```{r}

source("SSF simulation functions.R")
final.database(for.immigration="Y",
               focal.patch=patches.immigration,
               name.input.database=raw.results.immigration,
                         name.output.dataframe=results.immigration)


#save(raw.results.immigration,file="immigration results raw list focal patch 13 freq bird 851.Rdata")

```

```{r}

total.fruits.simulation<-length(patches.immigration)*num.sim.points.per.patch*num.sim.per.point

library("dplyr")
#Subset rows were prop.immigrated > 0 for the 3 different times
d<-results.immigration %>% 
                    filter(prop.immigrated>0) %>% 
                    filter(time==20 |
                               time==40 |
                               time==60) %>% 
                    summarise(prop.seeds.same.patch=sum(same.patch)/total.fruits.simulation,
                              prop.seeds.matrix=sum(matrix)/total.fruits.simulation,
                              prop.seeds.new.patch=sum(new.patch)/total.fruits.simulation,
                              prop.seeds.immigrated=sum(immigrated)/total.fruits.simulation) %>% as.matrix(.)

jpeg(paste("Graphs/Immigration bird frequency ",id.freq,".jpg"),quality=100,width=1000,height=700)
par(cex=1.5)
barplot(d,main=paste("Id frequency ",id.freq),xlab="Seed faith",ylab="Proportion",names.arg=c("Focal patch","Matrix","New patch","Immigrated"),cex.names=1.5,cex.axis=1.5,cex.main=1.5,cex.lab=1.5)

dev.off()


```


```{r}
##Obtain the dispersal distance for each fix rate
source("SSF simulation functions.R")
dispersal.distance(focal.patch=patches.immigration,
                   name.input.database=raw.results.immigration)
```


```{r}
#Obtain the information from the list in a data base including the seed dispersal distance
raw.dataframe(for.immigration="Y",
              for.seed.dispersal="Y",
                focal.patch=patches.immigration,#here I put the focal patches where the simulation started to estimate the immigration to the focal patch (which is 1) 
                name.input.database=raw.results.immigration,
                name.output.dataframe=patches.immigration.dispersal.distance)  

```



```{r}
library(ggplot2)
patches.immigration.dispersal.distance %>% 
  filter(time==20 |
           time==40 |
           time==60) %>% 
  ggplot(aes(x=dispersal.distance,y=immigrated)) +
  geom_point(position = position_jitter(height = 0.1, width = 0), alpha = 0.5) +
  geom_smooth(method = "glm", 
    method.args = list(family = "binomial"), 
    se = TRUE,col="red") +
  facet_wrap(~time) +
  xlab("Distance from source (m)") +
  ylab("Probbility of immigration to focal patch")
ggsave(paste("Graphs/distance from source bird frequency ",id.freq,".jpg"))

patches.immigration.dispersal.distance %>% 
  filter(time==20 |
           time==40 |
           time==60) %>%  
  ggplot(aes(y=dispersal.distance)) +
  geom_boxplot() +
  facet_wrap(~time)

```


```{r}

delete<-results.immigration %>% 
  select("focal.patch","time","same.patch","matrix","new.patch","immigrated") %>% #Select columns that I need information
  gather("faith","counts",c("same.patch","matrix","new.patch","immigrated")) %>% #You have to put the column name of the new column where the long levels will be stored (faith), column name where the results will be stored (counts), and then whaat columns you want to make in a long format and you leave out the columns that you want to use for the aggregate
  group_by(time,faith) %>% 
  summarise(counts=sum(counts)) %>% 
  spread(faith, counts)
  


results.immigration.long<-melt(database.simulations[,c("focal.patch","time","same.patch","matrix","new.patch","immigrated")],id.vars=c("focal.patch","time"))

results.immigration.long<-aggregate(results.immigration.long$value,by=list(faith=results.immigration.long$variable,
                                                                           time=results.immigration.long$time),FUN=sum)

#subset(results.immigration.long,results.immigration.long$time==20)

delete<-spread(results.immigration.long, faith, x)

delete<-cbind(delete,prop.table(as.matrix(delete[,c("same.patch","matrix","new.patch","immigrated")]),1))

#write.csv(delete,"borrar.csv",row.names=F)

```



