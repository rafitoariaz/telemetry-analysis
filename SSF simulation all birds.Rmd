---
title: "SSF simulation all birds"
author: "Luis Antonio Arias Medellin"
date: "August 13, 2019"
output: html_document
---

#MULTIPLE BIRDS

## FORMAT DATA BASE FOR ANALYSIS

http://tlocoh.r-forge.r-project.org/tips/isopleth_overlap_auto.html

## Load required packages

```{r, include=FALSE}
#Load libraries
library("openxlsx")
library("NISTunits")
library("rgdal")
#library("ggmap")
library("SDMTools")
library("raster")
#library("MetaLandSim") # need to run code source("https://bioconductor.org/biocLite.R") biocLite("Biobase")
#library("rgeos")
library("maps")
#library("maptools")
#library("geosphere")
library("amt")
library("tidyr")
#library("cowplot")
#library("reshape2")
library("dplyr")
library("ggplot2")
#library("ggrepel")
library("GGally")
library("parallel")
library("doParallel")
library("foreach")
library("sp")
library("stats")
#library("knitr")
```

```{r}
#Convert the Rmd file to R file so that it can be read on the super computer
#purl("SSF simulation all birds.Rmd",output="SSF simulation all birds R file.R")

```


#Prepare GPS data

```{r, include=FALSE}
#Remove anything on workspace
rm(list=ls(all=TRUE))

#Source functions
source("Clean SSF data base.R") #I just dpulicated the code I used for cleaning the tleemtry data just in case I modified the latter, so to avoid that the changes affect the present code 

#Fuction for cleaning telemetry data base
clean.tel.data()

#Copy data base
original.database<-prueba

#Select only columns of interest
original.database<-original.database[,c("LOCATION.X","LOCATION.Y","TIME","FREQ")]

#Rename columns
colnames(original.database)<-c("x","y","t","id")

#Number of GPS points per individual
original.database %>%
  group_by(id) %>% 
  summarise(num.obs=n()) %>% 
  ungroup() %>% 
  arrange(desc(num.obs))

#Remove elements that I will not use
rm(clean.freq,clean.tel.data,prueba,m)
```

#Prepare map

```{r}
#Load raster
land_use_raster<-raster("Map layers/Aug27_15rasters/forest27")

#Make a matrix to reclsify values from 1 to 1 and the new value is 0
m<-matrix(c(0,1,0,
            1,2,1),ncol=3,byrow=T) 

#Reclassify values
land_use_raster<-reclassify(land_use_raster,m)
names(land_use_raster) <- "forest27"

rm(m)
```

#Prepare information that will have the frequency of each individual, the patch were it was captured and the information of each patch where the individual was captured

```{r}
#Read excel data base of patch id, patch size and % forest
patches.info<-read.xlsx("Data bases/Information patches Costa Rica.xlsx",sheet=1)
freq.patches<-read.xlsx("Data bases/Frequencies patches.xlsx",sheet=1)

#Keep columns of interest
patches.info<-patches.info[,c("PATCH_ID","PERCENT_FOREST","ELEVATION","Psize")]

#Rename columns
colnames(patches.info)<-c("Patch","percent_forest","elevation","patch_size") #****There is no information on patch 15, 27, 28, 35, 62, 63. Patches 12 and 39 are on the database but there is no information since they have NA

```


```{r}
#Create a data frame with id as the first column and the second column has a data frame inside it with the x,y and time (t)
condensed.dataframe <- original.database %>% nest(-id)

#Show the frequency of the birds I followed
unique(condensed.dataframe$id)

#Subset certain individuals since I cannot run the code with certain frequencies. ****CHECK LATER HOW TO RUN THE CODE WITH ALL FREQUENCIES
condensed.dataframe.subset<-subset(condensed.dataframe,condensed.dataframe$id==232 |
                  condensed.dataframe$id==881 |
                  condensed.dataframe$id==942 |
                  condensed.dataframe$id==312 |
                  condensed.dataframe$id==171 |
                  condensed.dataframe$id==352 |
                  condensed.dataframe$id==511 |
                  condensed.dataframe$id==551 |
                  condensed.dataframe$id==731 |
                  condensed.dataframe$id==760 |
                  condensed.dataframe$id==851 |
                  condensed.dataframe$id==881 |
                  condensed.dataframe$id==973 |
                  condensed.dataframe$id==392 |
                  condensed.dataframe$id==202) 

#dat_all_original$id==472
#dat_all_original$id==910
#dat_all_original$id==821
#dat_all_original$id==791
#dat_all_original$id==702
#dat_all_original$id==672
#dat_all_original$id==631
#dat_all_original$id==591                 
#dat_all_original$id==273) #Just added this one
#dat_all_original$id==432) #Just added this one
#432 only moved in forested area, so the interaction terms of step length and habitat selection between habitats is not working since there are no steps in the matrix
#273 has only 4 movments in the forest, so the interaction is not working
#591 only moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there are no steps in the FOREST
#631 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 1 step in the FOREST
#672 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#702 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#791 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#821 MOSTLY moved in forest area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the matrix
#910 MOSTLY moved in MATRIX area, so the interaction terms of step length and habitat selection between habitats is not working since there IS 0 step in the FOREST
#472 is giving me a very unsual value of the parameter and I do not know why

#273, 352,511 472, 591, 672, 702, 791, 821, 973, 202 cannot fit model
#312, 171,731, 760, 392, 631, 851 give NA or INF values on estimate or confidence intervals
```

```{r}
#Make a track for each individual
condensed.dataframe.subset <- condensed.dataframe.subset %>%
mutate(trk = lapply(data, function(d) {
mk_track(d, x, y, t )
}))
```

```{r}
#Summarize sampling rate of all individuals
condensed.dataframe.subset %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>%
select(id, sr) %>% unnest
```

#Make tracks
```{r}


condensed.dataframe.subset <- condensed.dataframe.subset %>% mutate(ssf = lapply(trk, function(x) {
x %>% 
    track_resample(rate = minutes(5), tolerance = minutes(2)) %>% #A track will be considered if the two consecutive GPS points are separated by 5 minutes +- 2 minutes of tolerance
    filter_min_n_burst(min_n = 3) %>% #Keep only tracks that have three consecutive locations, which is the minimum requeried for doing the analysis
    steps_by_burst() %>% #Converts the points to tracks
    random_steps() %>% #Makes 9 random steps
    extract_covariates(land_use_raster, where = "both") %>% #Extracts covariates of vegetation on initial and ending location. In "amt tutorial.pdf" it explains the following: covariate values at the start and the end of a step can also be included in the model as interaction with each other, to test hypotheses of the type: Are animals more likely to stay in a given habitat, if they are already in the habitat?
    mutate(forest27_start = factor(forest27_start, levels = c(0, 1), labels = c("matrix", "forest"))) %>% #factor (forest27_start you have to check the name of the column of the data base that is generated one step before (in this case is forest27_start). Just run the 2 precedent pipe lines and a tibble with the names of the column will appeaar)
    mutate(forest27_end = factor(forest27_end, levels = c(0, 1), labels = c("matrix", "forest"))) %>% 
    mutate(log_sl_ = log(sl_)) #Obtain logarithm of step lenght
}))

```

#Plot habitat selection by bird (includes all birds)
```{r,purl=FALSE}
#Obtain the information from the condensed data frame
tracking.database.unlisted<- condensed.dataframe.subset %>% 
  select(id, ssf) %>% 
  unnest %>%
  select(id,case_,step_id_,sl_,ta_,forest27_start,forest27_end,log_sl_) %>% 
  filter(case_==TRUE) %>% 
  ungroup()


counts<-table(tracking.database.unlisted$forest27_end,tracking.database.unlisted$id)
par(mar=c(5,5,2,9),xpd=T)
barplot(counts,xlab="Bird id",ylab="Proportion of GPS points per habitat",col=c("grey50","grey"),las=2)

legend("topright",legend=c("Non-forested area","Forested area"),fill=c("grey","grey50"),bty="n")

counts<-data.frame(prop.table(t(counts),margin=1))

counts<-cbind(counts[1:(nrow(counts)/2),c("Var1","Freq")],counts[((nrow(counts)/2)+1):nrow(counts),"Freq"]) 
colnames(counts)<-c("freq","matrix","forest")
counts<-counts[order(-counts$matrix),]
counts.matrix<-t(data.matrix(counts[,c("matrix","forest")]))
colnames(counts.matrix)<-counts[,1]

#jpeg("Graphs/forest end by id frequency.jpg",quality=100,width=1000,height=700)
##**FOR THE FORESTED AREA, A LOT OF FREQUENCIES DO NOT HAVE OBSERVATION. IN ADDITION, THE PROPORTION OF 
par(mar=c(5,5,2,9),xpd=T)
barplot(counts.matrix,xlab="Bird id",ylab="Proportion of GPS points per habitat",col=c("grey","grey50"),las=2)

legend(x=17,y=0.8,legend=c("Non-forested area","Forested area"),fill=c("grey","grey50"),bty="n")


#dev.off()



#Step length by bird
tracking.database.unlisted %>% 
  mutate(id=as.factor(id)) %>% 
  ggplot(aes(x=id,y=log_sl_)) +
  geom_boxplot() +
  xlab("Bird id") +
  ylab("Log step length")
#ggsave("Graphs/Step length by bird.jpg")


#Turning angle by bird
tracking.database.unlisted %>% 
  mutate(id=as.factor(id)) %>% 
  ggplot(aes(x=id,y=ta_)) +
  geom_boxplot() +
  xlab("Bird id") +
  ylab("Turning angle") +
  geom_hline(yintercept=c(-180,180),linetype="dashed")
#ggsave("Graphs/Turning angle by bird.jpg")

##**CONTINUE HERE. FOR THE RESULTS, I CAN DO A DENSITY PLOT OF THE TURNING ANGLE AND STEP LENGHT
 
rm(counts,counts.matrix)
```

#LM for differences between step length in patches

```{r,purl=FALSE}
#Merge variables of movement behavior with environmental variables of patches. #**Although now that I think about it, it would be better to have the environmental variables of a buffer of each step
tracking.database.unlisted<-freq.patches %>% 
  inner_join(tracking.database.unlisted,by=c("FREQ"="id")) %>% 
  inner_join(patches.info,by=c("PATCH"="Patch")) %>% 
  mutate(logpatch_size=log(patch_size)) %>% 
  select(FREQ,log_sl_,logpatch_size,percent_forest,elevation) 

tracking.database.unlisted %>% 
  ggpairs(upper=list(continuous="points"),lower=list(continuous="cor"))


library("nlme")
#Model without random structure
summary(mod.1<-gls(log_sl_ ~logpatch_size+percent_forest+elevation,method = "REML", data = tracking.database.unlisted))


#GLMM nesting frequency
#mod.2<-lme(log_sl_~logpatch_size+percent_forest+elevation,random = ~1 | FREQ,data=d,method="REML")
#summary(mod.2)

#without patch size
#mod.3<-lme(log_sl_~percent_forest+elevation,random = ~1 | FREQ,data=d,method="REML")
#summary(mod.3)

#Without percent of forest
#mod.4<-lme(log_sl_~elevation,random = ~1 | FREQ,data=d,method="REML")
#summary(mod.4)

#library("MuMIn")
#Weights(AIC(mod.1,mod.2,mod.3,mod.4))

tracking.database.unlisted %>% 
  ggplot(aes(x=elevation,y=log_sl_)) +
  geom_point() + 
  geom_smooth(method="lm",col="red")
```



#Fit models
```{r}
#This was the original model, which used log_sl and sl in the same model. The authors did it that way, although it is weird that two variables that are transformed are used in the same model. I will use only one of them to fit the model
#m2 <- m2 %>% mutate(fit = map(ssf, ~ fit_issf(.,case_ ~ forest27_end + log_sl_ + sl_  + log_sl_:forest27_end + sl_:forest27_end + strata(step_id_))))

condensed.dataframe.subset <- condensed.dataframe.subset %>% 
  mutate(fit = map(ssf, ~ fit_issf(.,case_ ~ forest27_end + log_sl_ + ta_  + log_sl_:forest27_end + ta_:forest27_end + strata(step_id_))))
```


```{r}
#MAKE DATA BASES FOR ANALYSIS

#Make a data base with the values of each parameter. 
parameters.simulations <- data.frame(id.simulation=condensed.dataframe.subset$id) #*** IN THIS LINE I WOULD PUT THE NUMBER OF SIMULATIONS I WOULD LIKE TO DO, BUT NO I AM PUTTING THE ID OF THE BIRD SINCE EACH ONE HAS A SPECIFIC PARAMTER

for (i in 1:nrow(condensed.dataframe.subset)) {
  
  parameters.simulations$shape.step.length[[i]] <- sl_shape(condensed.dataframe.subset$fit[[i]])  #It uses a gamma distribution for step length. I think this is the mean. ***Understand why are they using a gamma distribution. HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE GAMMA DISTRIBUTION I WOULD LIKE TO SIMULATE
  
  parameters.simulations$scale.step.length[[i]] <- sl_scale(condensed.dataframe.subset$fit[[i]]) #It uses a gamma distribution for step length. I think this is the scale, which is part of what will determine the distribution ***Understand why are they using a gamma distribution. HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE GAMMA DISTRIBUTION I WOULD LIKE TO SIMULATE

  
  parameters.simulations$habitat.utilization[[i]] <- coef(condensed.dataframe.subset$fit[[i]])["forest27_endforest"] #***HERE ALSO I WILL PUT THE DIFFERENT VALUES FOR THE HABITAT SELECTION COEFFICIENT I WOULD LIKE TO SIMULATE
  
}

#Make a splitted list with the id. of the simulation number
#parameters.simulations<-split(parameters.simulations,parameters.simulations$num.simulation)




#This chunk is for obtaining the coordinates of the focal patch from Adam's data base and then figuring out the patch id in the croppped labeled map. ***MAYBE HERE I CAN CREATE A DATA BASE WITH THE XY COORDINATES OF THE PATCHES WHERE I WOULD LIKE TO DO THE SIMULATIONS
#Import data base with information about patches and xy locations of the patch
patches.locations<-read.xlsx("Data bases/Information patches Costa Rica.xlsx",sheet=1)

#Select columns with patch and coordinates information
patches.locations<-patches.locations[,c("PATCH_ID","X","Y")]

#Import data base with information about frequencies with patches
frequencies.patches<-read.xlsx("Data bases/Frequencies patches.xlsx",sheet=1)

#MErge the patches where birds were sampled with xy information
frequencies.patches<-merge(frequencies.patches,patches.locations,by.x="PATCH",by.y="PATCH_ID",all=T)

#Remove data base
rm(patches.locations)

#Create an object with the land use raster map but labelled
land_use_raster_labeled<-ConnCompLabel(land_use_raster)

#I will make a list of the patches where the birds will be moving. ###***HERE I CAN MODIFY THE CODE SO THAT I CAN PUT ANY PATCH I WANT. FOR NOW I AM USING PATCHES WERE THE BIRDS WERE CAPTURED
#Make a list with the forest raster cropped to the extent of the animal that moved
structure <- list(id.freq=numeric(),forest.raster.cropped=list())

#Make a splitted list with the id. freq. ***HERE I COULD USE THE LAND_USE_RASTER (THIS IS, THE COMPLETE MAP OF THE LANDSCAPE BUT LABALED) TO DO THE LIST SO THAT I HAVE REPRESENTED EACH PATCH OF THE LANDSCAPE. aLTERNATIVELY, FOR MY THESIS I CAN LOCATE THE PATCH IN THE LAND_USE_RASTER BASED ON THE PATCHES.LOCATION OBJECT (WHICH HAS THE XY COORDINATES OF THE PATCH WHERE THE BIRD WAS CAPTURED, SEE BELOW) TO SELECT ONLY THOSE PATCHES AND DO THE SIMULATIONS ONLY IN THOSE PATCHES. I COULD USE THE frequencies.patches DATA BASE (WHERE I AM PLANNING TO PUT THE XY LOCATIONS OF THE PATCHES WHERE I WOULD LIKE TO DO THE SIMULATIONS) TO SPLIT IT AND THEN USE THAT INFORMATION TO DO THE SIMULATIONS
forest.raster.cropped<-split(condensed.dataframe.subset$id,condensed.dataframe.subset$id)

#Construct the list with the elements
for (i in 1:length(forest.raster.cropped)){
  
  #Copy the structure of the list I want
  forest.raster.cropped[[i]] <- structure
  
  #Put the id. freq. ***HERE I WOULD PUT THE PATCH ID. I THINK I AM PUTTING THE ID.FREQ BECAUSE IT IS BASED ON WHERE THE BIRD MOVED. ON THE FUTURE I WILL NOT NEED THIS BECAUSE I WILL HAVE THE XY COORDINATES OF THE PATCHES WHERE I WANT TO DO THE SIMULATION 
  forest.raster.cropped[[i]]$id.freq <- condensed.dataframe.subset$id[[i]] 
  
  #Obtain the x y values of the focal patch. ###HERE I AM USING THE INFORMATION FROM ADAM FROM THE COORDINATES WHERE THE BIRDS WHERE CAPTURED, BUT I CAN USE ANY XY COORDINATE WHERE I WANT TO DO THE SIMULATION AND THEN OBTAIN THE INFORMATION OF THE CELL NUMBER FOR THE COMPLETE MAP OR THE CROPPED MAP (NEXT LINES)
  forest.raster.cropped[[i]]$focal.patch.xy <- subset(frequencies.patches,frequencies.patches$FREQ==forest.raster.cropped[[i]]$id.freq)[,c("X","Y")]
  
  #Obtain the cell number from the xy cordinate from the complete raster map
  forest.raster.cropped[[i]]$focal.patch.label.complete.map <- land_use_raster_labeled[cellFromXY (land_use_raster_labeled, forest.raster.cropped[[i]]$focal.patch.xy)]
  
  #Crop the map to the area in which the animal moved. #****NOW I AM CROPPING THE MAP BASED ON THE PLACES WHERE THE BIRD MOVED, BUT I COULD CROP THE MAP BASED ON THE LOCATION OF THE PATCH WHERE I WANT TO DO THE SIMULATION
  forest.raster.cropped[[i]]$forest.raster.cropped <- crop(land_use_raster, amt::bbox(condensed.dataframe.subset$trk[[i]], spatial = TRUE, buff = 1e3))
  
  #Store movment kernel
  #forest.raster.cropped[[i]]$movement.kernel <- movement_kernel(parameters.simulations$scale.step.length[[i]], parameters.simulations$shape.step.length[[i]], forest.raster.cropped[[i]]$forest.raster.cropped)
  
  #Store habitat kernel
  #forest.raster.cropped[[i]]$habitat.kernel <- habitat_kernel(list(forest27 = parameters.simulations$habitat.kernel[[i]]), forest.raster.cropped[[i]]$forest.raster.cropped)
  
  #Sotre forest raster labaled.
  forest.raster.cropped[[i]]$forest.raster.cropped.labeled<-ConnCompLabel(forest.raster.cropped[[i]]$forest.raster.cropped)
  
  #Obtain the cell number from the xy cordinate from the cropped raster map. ***I HAVE THE CORRECT VALUES OF THE RASTERS, I ONLY NEED TO MODIFY THE CODE SO THAT IT WORKS WITH THIS MODIFICATION
  forest.raster.cropped[[i]]$focal.patch.label.cropped <- forest.raster.cropped[[i]]$forest.raster.cropped.labeled[cellFromXY (forest.raster.cropped[[i]]$forest.raster.cropped.labeled, forest.raster.cropped[[i]]$focal.patch.xy)]
  
  
  
}



rm(structure)
```

### Plot

```{r}

#Obtain the parameters with their confidence internvals
graph.parameters.database <- condensed.dataframe.subset %>% mutate(coef = map(fit, ~ broom::tidy(.x$model))) %>%
select(id, coef) %>% unnest %>%
mutate(id = factor(id),
       term=if_else(term=="forest27_endforest","Habitat selection",term),
       term=if_else(term=="log_sl_","Log step length",term),
       term=if_else(term=="ta_","Turning angle",term),
       term=if_else(term=="forest27_endforest:log_sl_","Log step length by habitat",term),
       term=if_else(term=="forest27_endforest:ta_","Turning angle by habitat",term)) %>% group_by(term) %>%
summarize(
mean = mean(estimate),
ymin = mean - 1.96 * sd(estimate),
ymax = mean + 1.96 * sd(estimate)
)

graph.parameters.database$x <- 1:nrow(graph.parameters.database)
data <- condensed.dataframe.subset %>% mutate(coef = map(fit, ~ broom::tidy(.x$model))) %>%
select(id, coef) %>% unnest %>% 
mutate(id = factor(id)) #filter(conf.low!=-Inf)  %>% #I added this line since there are -inf values on the data set 

#Plot small version of the plot
data %>% 
  mutate(term=if_else(term=="forest27_endforest","Habitat selection",term),
         term=if_else(term=="log_sl_","Log step length",term),
         term=if_else(term=="ta_","Turning angle",term),
         term=if_else(term=="forest27_endforest:log_sl_","Log step length by habitat",term),
         term=if_else(term=="forest27_endforest:ta_","Turning angle by habitat",term)) %>% 
  ggplot(., aes(x = term, y = estimate, group = id, col = id)) +
# geom_rect(mapping = aes(xmin = x - .4, xmax = x + .4, ymin = ymin,
# ymax = ymax, y = mean), data = d2 %>% mutate(x = as.numeric(x)), inherit.aes = FALSE,
# fill = "grey90") +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high),
position = position_dodge(width = 0.7), size = 0.8)  +
  geom_errorbar(data = graph.parameters.database, aes(x = term, y = mean, ymin = mean, ymax = mean), inherit.aes = FALSE,
size = 1) +
geom_hline(yintercept = 0, lty = 2) +
labs(x = "Parameters", y = "Relative Selection Strength") +
theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
    #+
#scale_x_discrete(labels = c("Developed (open)", "Developed (other)", "Natural", "Crops","Other","Step length"))
#p1
#ggsave("img/fig_all_animals.pdf", width = 24, height = 12, units = "cm")
#ggsave("fig_all_animals_parameters_luis.pdf", width = 24, height = 12, units = "cm")
#ggsave("Graphs/Multi bird parameters.jpg")



#Make a density plot of the parameters
data %>%
  mutate(term=if_else(term=="forest27_endforest","Habitat selection",term),
         term=if_else(term=="log_sl_","Log step length",term),
         term=if_else(term=="ta_","Turning angle",term),
         term=if_else(term=="forest27_endforest:log_sl_","Log step length by habitat",term),
         term=if_else(term=="forest27_endforest:ta_","Turning angle by habitat",term)) %>% 
  ggplot(aes(x=estimate)) + 
  geom_histogram(aes(y=..density..),colour="black", fill="white") +
  geom_density(alpha=.2, fill="#FF6666") +
  facet_wrap(~term,scales="free")
  

rm(graph.parameters.database)
```


Run replicate simulations:

```{r}
#Soruce simulation functions
source("SSF simulation functions all birds.R")

#Set up the number of simulations per patch and also number of simulations per starting point
num.sim.points.per.patch<-50
num.sim.per.point<-1

#Make a list of the
results.simulations.list <- split(parameters.simulations$id.simulation,parameters.simulations$id.simulation)

registerDoParallel(detectCores())
#registerDoParallel(10)

#1,2,4,8,13,15,17,18
#for (i in 1:nrow(parameters.simulations)){
results.simulations.list <- foreach (i=c(1,2,4,9,11,13,14),#c(1,4),
                                .packages=c("amt","raster")) %dopar% {

simulate.movement(focal.patch=forest.raster.cropped[[i]]$focal.patch.label.cropped,
                  tot.num.minutes=60,
                  fix.rate=5,
                  parameters.simulations=parameters.simulations,
                  num.sim.points.per.patch=num.sim.points.per.patch, #I tried to only put a number and then save the number I put with the name of the variable but I could not do it, so that is why I specifya outside the function the value and store in in the variable
                  num.sim.per.point=num.sim.per.point, #I tried to only put a number and then save the number I put with the name of the variable but I could not do it, so that is why I specifya outside the function the value and store in in the variable
                  map.full=land_use_raster,
                  map.cropped=forest.raster.cropped[[i]]$forest.raster.cropped,
                  map.cropped.labeled=forest.raster.cropped[[i]]$forest.raster.cropped.labeled,
                  name.output.list=raw.results.emigration)


  
}



stopImplicitCluster()

#save.image(file="results.simulations2.RData")
```


```{r}
#Obtain the information from the list in a data base. ####CONTINUE HERE. I THINK THAT THE STRUCTURE OF THE DATA BASE IS DIFFERENT BECAUSE I AM USING A FOREACH LOOP. UNDERSTAND THE NEW STRUCTURE SO THAT I CAN MODIFY THIS CODE. 
#raw.dataframe(#focal.patch=focal.patch,
 # name.input.database=results.simulations2,
              #name.output.dataframe=raw.formated.results.emigration)

#***ADDED THIS CHUNK OF CODE. IT IS THE CODE I HAVE FOR THE FUNCTION raw.dataframe BUT OUTSIDE IS WORKING
  #Create a data frame with 1 row and the number of columns so that it matches the data frame 
  #I generated for each simulation (in this case is called results.simulations2). I am using the
  #first element of the list as a molde
  results.simulations.df<-data.frame(matrix(0,
                                          ncol=ncol(results.simulations.list[[1]][[1]][[1]][[1]]),
                                          nrow=1)) 
  
  #Name columns
  names(results.simulations.df)<-names(results.simulations.list[[1]][[1]][[1]][[1]])


  #Paste all data bases
  for (z in 1:length(results.simulations.list)){
    
    for(a in 1:length(results.simulations.list[[z]])){
      
      for (g in 1:num.sim.points.per.patch){
        
        for(l in 1:num.sim.per.point)
      {
        
        df<-results.simulations.list[[z]][[a]][[g]][[l]]
        
        results.simulations.df<-rbind(df,results.simulations.df)
        
      }
    }
  }
  }
  
  
  #Delete last observation which has nothing
  results.simulations.df<-results.simulations.df[-nrow(results.simulations.df),]


```



```{r}
#Obtain data base with values aggregated by time and showing the proportion of fruit in each faith by time. ###***I DO NOT KNOW WELL HOW AM I GOING TO DO THIS ANALYSIS, SO I DO NOT KNOW WELL THE STRUCTURE OF THE DATA BASE. sPECIFICALLY, I DO NOT KNOW IF I HAVE TO INCLUDE THE PARAMETERS VALUES
final.database(name.input.database=results.simulations.df,name.output.dataframe=results.emigration)


```

```{r}
##Obtain the dispersal distance for each fix rate
dispersal.distance(#focal.patch=focal.patch,
                   name.input.database=results.simulations.list)
```

```{r}
#Obtain the information from the list in a data base including the seed dispersal distance
#raw.dataframe(#for.seed.dispersal="Y",
                #focal.patch=focal.patch,
                #name.input.database=results.simulations2,
                #name.output.dataframe=raw.results.emigration.dispersal.distance)  


###ADDED THIS CODE SINCE THE FUNCTION IS NOT WORKING
#Create a data frame with 1 row and the number of columns so that it matches the data frame 
  #I generated for each simulation (in this case is called results.simulations2). I am using the
  #first element of the list as a molde
  results.simulations.dispersal.distance.df<-data.frame(matrix(0,
                                          ncol=ncol(results.simulations.list[[1]][[1]][[1]][[1]]),
                                          nrow=1)) 
  
  #Name columns
  names(results.simulations.dispersal.distance.df)<-names(results.simulations.list[[1]][[1]][[1]][[1]])
  

  #Paste all data bases
  for (z in 1:length(results.simulations.list)){
    
    for(a in 1:length(results.simulations.list[[z]])){
      
      for (g in 1:num.sim.points.per.patch){
        
        for(l in 1:num.sim.per.point)
      {
        
        df<-results.simulations.list[[z]][[a]][[g]][[l]]
        
        results.simulations.dispersal.distance.df<-rbind(df,results.simulations.dispersal.distance.df)
        
      }
    }
  }
  }
  
  
  #Delete last observation which has nothing
  results.simulations.dispersal.distance.df<-results.simulations.dispersal.distance.df[-nrow(results.simulations.dispersal.distance.df),]
  


```

```{r,purl=FALSE}
#ANALYZE PARAMETERS VERSUS DISPERSAL DISTANCE
#dispersal.distance~param.shape.step.length + para.habitat.utilization + time
results.simulations.dispersal.distance.df %>% 
  select(dispersal.distance,param.shape.step.length,param.habitat.utilization,time) %>%
  ggpairs(upper=list(continuous="smooth"),lower=list(continuous="cor"))


#Model without random structure
summary(mod.1<-gls(dispersal.distance ~param.shape.step.length + param.habitat.utilization + time,method = "REML", data = results.simulations.dispersal.distance.df))


#GLMM nesting frequency
summary(mod.2<-lme(dispersal.distance ~param.shape.step.length + param.habitat.utilization + time,random = ~1 | id.simulation,data=results.simulations.dispersal.distance.df,method="REML"))

#Continue with LMM
#Without habitat utilization
summary(mod.3 <- update(mod.2,.~. -param.habitat.utilization))

#Without step length
summary(mod.4 <- update(mod.3,.~. -param.shape.step.length))


results.simulations.dispersal.distance.df %>% 
  ggplot(aes(x=time,y=dispersal.distance,group=time)) + 
  geom_boxplot() +
  geom_smooth(method="lm")

```

